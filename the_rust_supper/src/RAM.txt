

//**************************************************************************************************
// ENUM WITH GENERIC 2 TYPES
//**************************************************************************************************
enum DF<X,Y:Display,const N:usize>{
    TrainX([X; N]),
    TrainY(Y),
    TestXX([X; N]),
    TestYY(Y)
}


fn data_shape<X,Y:Display,const N:usize>(df:DF<X,Y,N>){
    match df{
        DF::TrainX(x)=>{println!("TrainX = {}",x.len())},
        DF::TrainY(x)=>{println!("TrainY = {}",x)},
        DF::TestXX(x)=>{println!("TestXX = {}",x.len())},
        DF::TestYY(x)=>{println!("TestYY = {}",x)},
    }
}

fn predict<const N:usize>(df:DF<f64,f64,N>,weight:[f64; N],bias:f64)->f64{
    match df{
        DF::TrainX(x)=>{
            dotproduct_f64(x,weight)+bias
        },
        DF::TestXX(x)=>{
            dotproduct_f64(x,weight)+bias
        },
        _=>{
            println!("Input is invalid");
            0.0
        }
    }
}

fn mean_square_error_f64<const N:usize>(df:DF<f64,f64,N>,weight:[f64; N],bias:f64,y:f64)->f64{
    let prediction = predict(df,weight,bias);
    (prediction-y).powf(2.0)
}

fn dotproduct_f64<const N:usize>(v:[f64; N],u:[f64; N])->f64{
    let mut count=0;
    let mut y=0.0;
    for i in v{
        y += i*u[count];
        count+=1;
    }
    y
}

//**************************************************************************************************
// TRAIT
//**************************************************************************************************
// https://doc.rust-lang.org/book/ch10-02-traits.html
trait SayMyName{
    fn my_name(&self) -> String{
        String::from("unknown")
    }
    fn say_my_name(&self) -> String{
        format!("{} (Unknown Type)",self.my_name())
    }
}

trait Greeting{
    fn hello(&self)->String{
        "Hello".to_string()
    }
    fn my_type(&self)->String{
        "is both Greeting and SayMyName.".to_string()
    }
}

enum Occupation{
    Programmer(String),
    Engineer(String),
    Scientist(String),
    Doctor(String),
    Artist(String),
    Writer(String),
    Teacher(String),
    Politician(String),
    Lawyer(String),
    Farmer(String)
}

enum TierList{
    S,
    A,
    B,
    C,
    D,
    F
}

struct Person{
    name:String,
    age:u32,
    occupation:Occupation,
    tierlist:TierList
}

impl SayMyName for Person{
    fn say_my_name(&self)->String{
        format!("{} (Person)",self.name.to_string())
    }
}

struct CEO<const N:usize>{
    name:String,
    age:u32,
    field:String,
    workers:[Person;N]
}

impl <const N:usize>SayMyName for CEO<N>{
    fn say_my_name(&self)->String{
        format!("{} (CEO)",self.name.to_string())
    }
}

// https://users.rust-lang.org/t/how-to-exclude-a-type-from-generic-trait-implementation/26156/5
impl <T> SayMyName for Array<T> {}
impl <N: ArrayLength> SayMyName for [Array<[&str::N]>]{
// impl <const COUNT: usize> SayMyName for [Array<&str, COUNT>] {
    fn my_name(&self) -> String{
        (*self)[0].data[0].to_string()
    }
}
impl <N: ArrayLength> Greeting for [Array<[&str::N]>]{}

// Traits as Parameters
fn is_1st_char_capital(name:&impl SayMyName){
    // https://www.educative.io/answers/how-to-check-if-a-character-is-uppercase-in-rust
    // https://stackoverflow.com/questions/30811107/how-do-i-get-the-first-character-out-of-a-string
    name.say_my_name().chars().nth(0).unwrap().is_uppercase()
}

fn count_char(name:&impl SayMyName){
    // https://stackoverflow.com/questions/46290655/does-rusts-string-have-a-method-that-returns-the-number-of-characters-rather-th
    name.say_my_name().chars().count()
}

// Trait Bound Syntax
fn count_unknown_name<T: SayMyName, const N:usize>(item:[T;N]){
    let mut count:i32=0;
    for i in item{
        if i.say_my_name()=="unknown (Unknown Type)".to_string(){
            count+=1
        }
    }
    count
}

fn greet_ii(item: &(impl SayMyName + Greeting))->String {
    format!("{}, my name is {}",item.hello(),item.say_my_name())
}

fn its_type_ii<T:SayMyName + Greeting>(item:&T)->String {
    format!("{} {}",item.say_my_name(),item.my_type)
}

fn println_2types<T,U,COUNT>(cheche:T,avatar:U)where 
    T:SayMyName,
    U:SayMyName+Greeting
{
    println!("Person = {}",cheche.say_my_name());
    println!("Array  = {}",avatar.greet_ii());
}

// fn ReturnArray(n:usize,text:&str)->SayMyName{
//     Array{
//         data:[text;n]
//     }
// }