.to_string()
 

// ...Or Unicode code points.
 
             // 116
 
// let b_t=18;
 
:String
 
"t".to_string()
 
 as u16
 
t' as u16
 
println!("b_1 (dec) = {}",b_t);
 
 (hex)
 
println!("b_1 (dec) = {}",b_t);
 
:#03
 
.to_hex()
 
.as_slice()
 
:char
 
 as u16
 
let b_t:char='t';
println!("{}",b_t as u16);
 
.as_str()
 
let s3:String = s1+s2.as_str();
 
let mut s = String::from("hello");
s.push(',');
s.push_str(" world");
s.push_str("!");
 
.to_string()
 
, BOX<STR> AND &STR
 
li
 
.into()
 
//**************************************************************************************************
// CONVERT &STR TO STRING
//**************************************************************************************************

 
let no_permission:&str="git cimmit -m 'Create Cool Project'";
let have_permission:String="git cimmit -m 'Create Cool Project'".to_string();
let fork1:String=get_permission(no_permission);
let fork2:String=get_permission(&have_permission);
 
fn get_permission(a:&str)->String{
    return format!("{}",a)
}
 
.to_string()
 
//**************************************************************************************************
// PRINTLN EACH CHAR IN &STR
//**************************************************************************************************

 
// There are some character that terminal connot display
// because this loop iterate over the unicode scalar value of the string 
// instead of the character.
println!("'สวัสดีครับ = Hello'.chars()");
for b in "สวัสดีครับ = Hello".chars(){
    println!("{}",b);
    // ส
    // ว
    //
    // ...
    // o
};
 
println!("'สวัสดีครับ = Hello'.chars()");
for b in "สวัสดีครับ = Hello".graphemes(true){
    println!("{}",b);
    // ส
    // ว
    //
    // ...
    // o
};
 
use unicode_segmentation::UnicodeSegmentation;
 
use unicode_segmentation::;;
 
::Unicode_segmentation
 
 
 
// converting the &str to tupl
 
println!("message.chars() = {}","สวัสดีครับ = Hello".chars().to_string());
 
let firstchar:char='ส';
println!("firstchar = {}",firstchar as u8);
// firstchar = 42
 
// 224
// 184
// ...
// 111
 
/*
 
let get8thbytes=first10thaichar[7];
 
let get8thbytes=&first10thaichar.7;
 
/*
4*0-4*1
4*1-4*2
4*2-4*3
*/
 
3
 
let first10thaichar:&str = "กขฃคฅฆงจฉช";
 
let firstthaichar_as_bytes:String = "\u{"+firstthaichar.to_string()+"}";
 
ขฃคฅฆงจฉช
 
let helloworld:String = ["Hello"," ","World"].concat();
let helloworld:String = format!("{} {}","Hello", "World");
let helloworld:&str = concat!("Hello"," ","World");
let hello:String = String::from("Hello");
let helloworld:String = hello+" World";
 
FORMAT, 
 
let first_commit:String = String::from("git commit -c 'Creating New Project!'");
let second_commit:String = String::from("git commit -c 'developing version 2'");
let thrid_commit:&str = "git commit -c 'developing version 3'";
// FORMAT
let project_development:String = format!(
    "{}\n{}\n{}\n{}",
    first_commit,
    second_commit,
    thrid_commit,
    "git push origin main"
);
println!("{}",project_development);
// CONCAT
let project_development:&str = [
    first_commit,
    second_commit,
    thrid_commit.to_string().push_str("git push origin main")
].concat();
println!("{}",project_development);
 
let first_commit:String = String::from("git commit -c 'Creating New Project!'");
let second_commit:String = String::from("git commit -c 'developing version 2'");
let thrid_commit:&str = "git commit -c 'developing version 3'";
// FORMAT
let project_development:String = format!(
    "{}\n{}\n{}\n{}",
    first_commit,
    second_commit,
    thrid_commit,
    "git push origin main"
);
println!("{}",project_development);
// CONCAT
let project_development:&str = [
    first_commit,
    second_commit,
    thrid_commit.to_string().push_str("git push origin main")
].concat();
println!("{}",project_development);
}

 
    
 
.to_string()
 
    "{}\n{}\n{}\n{}",
 
String::from(
 
let no_permission_to_edit:&str = "git commit -c 'Creating New Project!'";
 
println!("{}",project_development);
project_development.push_str(" & git commit -c 'develop version 2'");
println!("{}",project_development);
project_development.replace_range(..,"git push origin main");
println!("{}",project_development);
 
let no_permission_to_edit:&str = "git commit -c 'Creating New Project!'";
let mut project_development:String = String::from(no_permission_to_edit);
println!("{}",project_development);
project_development.push_str(" & git commit -c 'develop version 2'");
println!("{}",project_development);
project_development.replace_range(..,"git push origin main");
println!("{}",project_development);
 
let fork_02:String = no_permission_to_edit.to_string();
let fork_03:String = no_permission_to_edit.to_owned();
let audience_only_read_github:&str = &fork_03[..];
let deployment:&str = &fork_03[13..];
let learning_git:&str = &fork_03[..13];
let commitment:&str = &fork_03[4..10];
let vitamin_c:&str = &commitment[..];
println!("let audience_only_read_github:&str = {}",audience_only_read_github);
println!("let edit_03:String = {}",fork_03);
println!("let deployment:&str = {}",deployment);
println!("let deployment:&str = {}",learning_git);
println!("let commitment:&str = {}",commitment);
println!("let vitamin_c:&str = {}",vitamin_c);
 
let fork_01:String = String::from(no_permission_to_edit);
let fork_02:String = no_permission_to_edit.to_string();
let fork_03:String = no_permission_to_edit.to_owned();
let audience_only_read_github:&str = &fork_03[..];
let deployment:&str = &fork_03[13..];
let learning_git:&str = &fork_03[..13];
let commitment:&str = &fork_03[4..10];
let vitamin_c:&str = &commitment[..];
println!("let audience_only_read_github:&str = {}",audience_only_read_github);
println!("let edit_03:String = {}",fork_03);
println!("let deployment:&str = {}",deployment);
println!("let deployment:&str = {}",learning_git);
println!("let commitment:&str = {}",commitment);
println!("let vitamin_c:&str = {}",vitamin_c);
 
    Capacity: 11
 
(length) of characters (in UTF8, each character has 1-4 
 
English 
 
English 
 
, allocate in heap
 

// use rand::Rng;
// use std::cmp::Ordering;
// use std::fs::File;
// use std::io;
// use std::io::{BufRead, BufReader, ErrorKind, Write};
// use std::ops::{Range, RangeInclusive};

fn push_str(s: &mut String) {
    s.push_str("world")
}
fn borrow_object(s: String) {}
fn borrow_and_object(s: &String) {}
fn borrow_mut_object(s: &mut String) {}
 
PRINTING THE MEMORY ADDRESS
 
// let x = 112;
// let p = &x;
// println!("the memory address of x is {:p}", p); 
// println!("the value of x is {}", p); 
// println!("the value of x is {:}", p); 

//**************************************************************************************************
// EXAMPLE NO.2 STAR (*) = ACCESSING THE ORIGINAL VALUE
//**************************************************************************************************
// let x = 5;
// let y = &x;
// //assert_eq!(5, y); // invalid
// assert_eq!(5, x);   // valid because x = 5
// assert_eq!(&5, y);  // valid because &5 = y  = the reference of 5
// assert_eq!(&x, y);  // valid because &x = y  = the reference of 5
// assert_eq!(&x, &5); // valid because &x = &5 = the reference of 5
// // * mean to access the original value that the pointer refer to.
// assert_eq!(5, *y);  // valid because 5 = *y  = the original value of 5
// assert_eq!(5, *&5); // valid because 5 = *&5 = the original value of 5
// assert_eq!(5, *&x); // valid because 5 = *&x = the original value of 5

//**************************************************************************************************
// EXAMPLE NO.3 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// // You must specify if the input value of the function
// // is mutable or immutable reference, or non-reference variable.
// // And the input value must match with the input attribute of the function.
// push_str(&mut s);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.4 ALL OF THE MUTABLE VARIABLE CANNOT HAVE IMMUTABLE REFERENCE.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// let p = &mut s;
// p.push_str("world");

//**************************************************************************************************
// EXAMPLE NO.5 REF IS THE SAME AS &, EXCEPT IT MAKE CODE MORE READABLE IN SOMECASE.
//**************************************************************************************************
// let c = '中';
// let r1 = &c;
// let ref r2 = c;
// assert_eq!(r1,r2);

//**************************************************************************************************
// EXAMPLE NO.6 USING MULTIPLE IMMUTABLE REFERENCE.
//**************************************************************************************************
// let mut s = String::from("hello");
// let r1 = & s;
// let r2 = & s;
// println!("{}, {}", r1, r2);

//**************************************************************************************************
// EXAMPLE NO.7 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let  s = String::from("hello, ");
// borrow_object(s);
// let mut s = String::from("hello, ");
// borrow_mut_object(&mut s);
// println!("No Error!");

//**************************************************************************************************
// EXAMPLE NO.8 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// borrow_and_object(&s);
// s.push_str("world");

//**************************************************************************************************
// EXAMPLE NO.9 VALID BECAUSE THE PREVIOUS MUTABLE REFERENCE IS NOT LONGER USED.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// let r1 = &mut s;
// r1.push_str("world");
// let r2 = &mut s;
// r2.push_str("!");
// println!("{}",r2);
 
//**************************************************************************************************
// EXAMPLE NO.9 VALID BECAUSE THE PREVIOUS MUTABLE REFERENCE IS NOT LONGER USED.
//**************************************************************************************************

 
borrow_object(s);
 
&mut 
 
: &mut String
 
// Fill the blank，dont change other code
 
    // Fill the blank to make it work
 
//assert_eq!(5, y); // invalid
 
in
 

    // Modify this line only
 
memory addres
 
   // Fill the blank
 
fn writing()->String{
    let text=String::from("Harry Potter");
    text    // allow
    //&text // does not allow because when text is not longer use
            // the reference that borrow the text cannot
            // reference the text anymore, causing dangling problem. 
}
 
    let book = writing();      
 
// In order to use multiple immutable and a mutable reference in different time
// the target variable must be mutable.
let mut exam = String::from("f'(x) = lim_{h->0} ( f(x+h) - f(x) ) / (h) ");
let honeststudent1=&exam;   // Rust does not allow both immutable and mutable reference.
let honeststudent2=&exam;   // Rust allows multiple immutable references.
println!("{}, {}",honeststudent1,honeststudent2);
// the cheater takes alone exam after 2 honest students finished the exam.
// So the cheater cannot cheat on the exam.
let cheater=&mut exam;      // Rust allows one mutable reference.
println!("{}",cheater);        
 
alone 
 
use std::mem::size_of_val;
use std::env;
 
env::remove_var(honeststudent1);
env::remove_var(honeststudent2);
 
fn add_his_famous_song(album: &mut String,songname:&str){
    album.push_str(songname)
}
 
println!("");
 
use std::mem::size_of_val;
 
.to_string()
 
songname:String
 
// another example
 
fn add_his_famous_song(album: String,songname:&str)->String{
    // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
    let mut album=album;
    let songname:&str=songname;
    album.push_str(songname)
}
 
    completealbum
 
let completealbum:String=
 
String::from(
 
String::from(
 
", One day you doing to die!"
 
.to_string()
 
.push_str(
 
mut 
 
mut 
 
&mut
 

fn take_ownership(s: String)->String {
    println!("{}", s);
    s
}
fn give_ownership() -> String {
    let s = String::from("Hello world");
    // Convert String to Vector u8
    // into_bytes switch the owner of HelloWorld from s to _s
    // as_bytes create new variable, and does not effect the owner ship of HelloWorld.
    let _s = s.as_bytes();
    s
}
fn print_str(s: String) ->String {
    println!("{}",s);
    s
}
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************
    // This cause error, because the variable can only have 1 ownership.
    // and String variable is heap variable that only be access by pointer.
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}, {}",x, y);

    // Solution 1
    // clone copy the heap data.
    // beware that the heap data is memory expensive
    // let x = String::from("Hello world");
    // let y = x.clone();
    // println!("{}, {}",x, y);

    // Solution 2
    // let x = String::from("Hello world");
    // let y = String::from("Hello world");
    // println!("{}, {}",x, y);

    // Solution 3
    // let x = String::from("Hello world");
    // println!("{}",x);

    // Solution 4
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}",y);

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
    //let s1 = String::from("Hello world");
    //let s2 = take_ownership(s1);
    //println!("{}", s2);

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
    //let s = give_ownership();
    //println!("{}", s);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
    // let s = String::from("Hello World");
    // let ss = print_str(s);
    // println!("{}", ss);

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
//let tupless:(i32,i32,i32,String,(),String)= (255,0,0,"Red".to_string(),()," is my Lucky Color!".to_string());
//let x:(i32,i32,(),&str) = (1, 2, (), "hello");
//let y = x;
//println!("{:?} == {:?}", x, y);
//let mut mbti:&str="intp";
//mbti="lgbt";
//mbti="UFO";
//mbti="pseudoscience";
//println!("{}",mbti);
/*
The similarity between &str and String
 * Both store string

The different between &str and String
 * String have unknown size
 * &str have fixed size.
*/

//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let s = String::from("Hello ");
// let mut s1 = s;
// s1.push_str("World!");

//**************************************************************************************************
// EXAMPLE NO.7
//**************************************************************************************************
// https://doc.rust-lang.org/rust-by-example/std/box.html
// By default the value is stored in stack.
// Box allow the value store in heap.
let x = Box::new(5);
println!("x = {}",x);
println!("*x = {}",*x);
let mut y=x.clone();
*y = 4;
assert_eq!(*x, 5);
// y is equal 5_i32
// y is stored in Stack.
let y=*x;
println!("y = {}",y);
println!("{}",x);

//**************************************************************************************************
// EXAMPLE NO.8 STRUCT
//**************************************************************************************************
// struct Coffee{
//     name:String,
//     cost:Box<i32>,
//     caffeine:Box<f32>,
//     sugar:f32,
//     water:f32,
// };
// let jojocofee=Coffee{
//     name:String::from("Yuzu Coffee"),
//     cost:Box::new(120),
//     caffeine:Box::new(2.5),
//     sugar:1.5,
//     water:4.0
// };
// println!("jojocofee.name = {}",jojocofee.name);
// println!("jojocofee.cost = {}",jojocofee.cost);
// println!("jojocofee.caffeine = {}",jojocofee.caffeine);
// let Coffee {name,cost,ref caffeine,sugar, ref water} = jojocofee;
// println!("let Coffee {{ name ,cost,ref caffeine,sugar, ref water}} = jojocofee;");
// // println!("jojocofee.name = {}",jojocofee.name); // Error
// println!("jojocofee.name = {}",name);
// println!("jojocofee.cost = {}",cost);
// println!("jojocofee.caffeine = {}",caffeine);
// println!("jojocofee.water = {}",water);

//**************************************************************************************************
// EXAMPLE NO.9
//**************************************************************************************************
// let t = (String::from("hello"), String::from("world"));
// // _s borrow the value of t
// let _s = &t;
// println!("{:?}", t);
// // let _s = String::from("hello")
// let _s = t.0;
// // t.1 == String::from("world")
// println!("{:?}", t.1);


//**************************************************************************************************
// EXAMPLE NO.10
//**************************************************************************************************
let t = (String::from("hello"), String::from("world"));
// Fill the blanks
let (s1, s2) = &t; // t.clone()
println!("{:?}, {:?}, {:?}", s1, s2, t);
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************
    // This cause error, because the variable can only have 1 ownership.
    // and String variable is heap variable that only be access by pointer.
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}, {}",x, y);

    // Solution 1
    // clone copy the heap data.
    // beware that the heap data is memory expensive
    // let x = String::from("Hello world");
    // let y = x.clone();
    // println!("{}, {}",x, y);

    // Solution 2
    // let x = String::from("Hello world");
    // let y = String::from("Hello world");
    // println!("{}, {}",x, y);

    // Solution 3
    // let x = String::from("Hello world");
    // println!("{}",x);

    // Solution 4
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}",y);

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
    //let s1 = String::from("Hello world");
    //let s2 = take_ownership(s1);
    //println!("{}", s2);

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
    //let s = give_ownership();
    //println!("{}", s);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
    // let s = String::from("Hello World");
    // let ss = print_str(s);
    // println!("{}", ss);

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
//let tupless:(i32,i32,i32,String,(),String)= (255,0,0,"Red".to_string(),()," is my Lucky Color!".to_string());
//let x:(i32,i32,(),&str) = (1, 2, (), "hello");
//let y = x;
//println!("{:?} == {:?}", x, y);
//let mut mbti:&str="intp";
//mbti="lgbt";
//mbti="UFO";
//mbti="pseudoscience";
//println!("{}",mbti);
/*
The similarity between &str and String
 * Both store string

The different between &str and String
 * String have unknown size
 * &str have fixed size.
*/

//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let s = String::from("Hello ");
// let mut s1 = s;
// s1.push_str("World!");

//**************************************************************************************************
// EXAMPLE NO.7
//**************************************************************************************************
// https://doc.rust-lang.org/rust-by-example/std/box.html
// By default the value is stored in stack.
// Box allow the value store in heap.
let x = Box::new(5);
println!("x = {}",x);
println!("*x = {}",*x);
let mut y=x.clone();
*y = 4;
assert_eq!(*x, 5);
// y is equal 5_i32
// y is stored in Stack.
let y=*x;
println!("y = {}",y);
println!("{}",x);

//**************************************************************************************************
// EXAMPLE NO.8 STRUCT
//**************************************************************************************************
// struct Coffee{
//     name:String,
//     cost:Box<i32>,
//     caffeine:Box<f32>,
//     sugar:f32,
//     water:f32,
// };
// let jojocofee=Coffee{
//     name:String::from("Yuzu Coffee"),
//     cost:Box::new(120),
//     caffeine:Box::new(2.5),
//     sugar:1.5,
//     water:4.0
// };
// println!("jojocofee.name = {}",jojocofee.name);
// println!("jojocofee.cost = {}",jojocofee.cost);
// println!("jojocofee.caffeine = {}",jojocofee.caffeine);
// let Coffee {name,cost,ref caffeine,sugar, ref water} = jojocofee;
// println!("let Coffee {{ name ,cost,ref caffeine,sugar, ref water}} = jojocofee;");
// // println!("jojocofee.name = {}",jojocofee.name); // Error
// println!("jojocofee.name = {}",name);
// println!("jojocofee.cost = {}",cost);
// println!("jojocofee.caffeine = {}",caffeine);
// println!("jojocofee.water = {}",water);

//**************************************************************************************************
// EXAMPLE NO.9
//**************************************************************************************************
// let t = (String::from("hello"), String::from("world"));
// // _s borrow the value of t
// let _s = &t;
// println!("{:?}", t);
// // let _s = String::from("hello")
// let _s = t.0;
// // t.1 == String::from("world")
// println!("{:?}", t.1);


//**************************************************************************************************
// EXAMPLE NO.10
//**************************************************************************************************
let t = (String::from("hello"), String::from("world"));
// Fill the blanks
let (s1, s2) = &t; // t.clone()
println!("{:?}, {:?}, {:?}", s1, s2, t);
 
2 Rules of Borrowing
* In anytime, ypu can have one of 2 things
 1. One mutable reference 
 2. any number of immutable reference 
* Reference must always be valid. (pointer must reference to the available data.)
 
// input borrow
 
 *
 
 by
 
let 
 
.clone()
 
// Modify this line only, don't use `_s`
 
println!("jojocofee.caffeine = ",jojocofee.caffeine);
 
println!("jojocofee.caffeine = ",jojocofee.water);
 
println!("let jojocofee=Coffee\{
    name:String::from('Yuzu Coffee'),
    cost:Box::new(120),
    caffeine:Box::new(2.5),
    sugar:1.5,
    water:4.0
};");
 
"let jojocofee=Coffee\{
    name:String::from('Yuzu Coffee'),
    cost:Box::new(120),
    caffeine:Box::new(2.5),
    sugar:1.5,
    water:4.0
};"
 
jojocofee.
 
ojocofee.
 
jojocofee.
 
ame, cost, caffeine, ref sugar, water
 
ref 
 
let x = Box::new(5);
 
 mut
 
 EXAMPLE NO.6
 
.to_string()
 
:(i32,i32,(),&str)
 
.to_string()
 
.to_string()
 
x, 
 
, {}
 
    //let y = x;
 
//, y);
 

    // Use as many approaches as you can to make it work
 
    let s3 = 
 
    // might do other things
 
UNIT
 
Example No.2
 
: SCOPE
 
// 2. drop input previous ownership.
 
// copy the data with fixed size
 
Size of message is 24 bytes
 
"Hello" belong to Heap.
 
*/
 
|
|
|
 
 len
 
// Its pointer indicate the position of "Hello"
 
  
 
   //**************************************************************************************************
    // CASE 01: EXPRESSION
    //**************************************************************************************************

    //let x = 5u32;
    //let y = {
    //    let x_squared = x * x;
    //    let x_cube = x_squared * x;
    //    x_cube + x_squared + x
    //};
    //println!("x is {:?}", x);
    //println!("y is {:?}", y);

    //**************************************************************************************************
    // CASE 02
    //**************************************************************************************************
    // let v = {
    //    let mut x = 1;
    //    x + 2
    //    // x +=2 // is wrong
    // };
    // println!("{}",v);
    // let statement_v = {
    //    let mut x = 1;
    //    x += 2;
    //    // return unit type
    // };


    //**************************************************************************************************
    // CASE 03: MATCH
    //**************************************************************************************************
    let input=1;
    match input{
        1=>println!("low"),
        2=>println!("median"),
        3=>println!("high"),
        _ =>println!("Invalid")
    };

    //**************************************************************************************************
    // CASE 04: DIVERGE FUNCTION AND PANIC
    //**************************************************************************************************
    // never_return();

    //**************************************************************************************************
    // CASE 05: MATCH AND PANIC
    //**************************************************************************************************
    // let b = false;
    // let _v = match b {
    //     // return 1
    //     true => 1,
    //     // return error.
    //     false => {
    //         println!("Success!");
    //         panic!("we have no value for `false`, but we can panic");
    //     }
    // };
 
// This is diverge function
fn never_return() -> ! {
    // panic make the complier show error.
    panic!("SOS");
}

fn get_option(tp: u8) -> Option<i32> {
    match tp {
        1 => {
            // TODO
        }
        _ => {
            // TODO
        }
    };
    
    // Rather than returning a None, we use a diverging function instead
    never_return_fn()
}

// IMPLEMENT this function in THREE ways
fn never_return_fn() -> ! {
    panic!("SOS");
    //unimplemented!();
    //todo!();
}

 
// Diverging functions can also be used in match expression to replace a value of any value
 
the fn signatures
 
    // Implement this function, don't modify 
 
"This function never returns!"
 
//
 
    println!("z is {:?}", z);
 
    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x
    };
 

        // This expression will be assigned to `y`
 
fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}

fn implicitly_ret_unit() {
    println!("I will return a ()");
}

// Don't use this one
fn explicitly_ret_unit() -> () {
    println!("I will return a ()");
}

// Explicitly return i32
fn one984(justthe:i32,two:i32)->i32{
    let ofus:i32=1;
    justthe+two+ofus
}
 
    //**************************************************************************************************
    // CASE 01: SIZE OF CHAR IS 4
    //**************************************************************************************************

    // let c1 = 'a';
    // let c2 = '中';
    // println!("bit size of c1 = {}",size_of_val(&c1)); // 4
    // println!("bit size of c2 = {}",size_of_val(&c2)); // 4

    //**************************************************************************************************
    // CASE 02: SINGLE QUOTE = CHAR , DOUBLE QUOTE = &STR
    //**************************************************************************************************
    // let c1:char='a';
    // let c2:&str="a";
    // println!("Type of c1 = {}",type_of(&c1));   // char
    // println!("Type of c2 = {}",type_of(&c2));   // &str

    //**************************************************************************************************
    // CASE 03: CONDITION
    //**************************************************************************************************

    // let thetruth:bool=true;
    // //let thetruth:bool=false;
    // let myname:&str="CheChe";
    // if myname=="Cheche"{
    //     println!("God.");
    // }
    // else{
    //     println!("Satan.");
    // };

    //**************************************************************************************************
    // CASE 03: AND
    //**************************************************************************************************
    // let f = false;
    // let t = true && false;
    // println!("{} == {}",f,t);

    //**************************************************************************************************
    // CASE 04: UNIT TYPE
    //**************************************************************************************************
    // The unit type is the data type that have 0 bits.
    // The function that does not return any value
    // will always return unit type.
    // let emptyset: () = (); 
    let tuplee: (i32,i32,i32)=(22,23,24);
    // println!("{}",one984(2,2));

    //**************************************************************************************************
    // CASE 05: SIZE OF UNIT TYPE
    //**************************************************************************************************
    let unit: () = ();
    println!("{}",size_of_val(&unit));  // 0
 
,thetruth
 
 tell {}
 
,thetruth
 
//let y: &[u8] = &x;
 
 and {}
 

fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}
 
    //**************************************************************************************************
    // CASE 01: ASSIGNED VALUE AS TYPE
    //**************************************************************************************************

    //#v = 38 that is assigned as u16
    //#38 is assigned as u8
    //let v: u16 = 38_u8 as u16;

    //println!("Success!");

    //**************************************************************************************************
    // CASE 02: DEFAULT VALUE
    //**************************************************************************************************
    // let x = 5;
    // println!("{}=={}",
    //     "i32".to_string(), 
    //     type_of(&x).to_string());

    //**************************************************************************************************
    // CASE 03: CHECKED_ADD AND UNWRAP
    //**************************************************************************************************
    // let v1 = 251_u16 + 8;
    // let v2 = i16::checked_add(251, 8).unwrap();
    // println!("{},{}",v1,v2);

    //**************************************************************************************************
    // CASE 04: 0XFF
    //**************************************************************************************************
    //#hexadecimal numeral system
    // println!("0xff = {}",0xff); // = 255
    // println!("0o77 = {}",0o77); // = 63
    // println!("0b1111_1111 = {}",0b1111_1111); // = 255

    //**************************************************************************************************
    // CASE 05: FLOATING POINT
    //**************************************************************************************************
    //let x64 = 1_000.000_1;
    //println!("{}==f64",type_of(&x64));

    //**************************************************************************************************
    // CASE 06: FLOATING POINT PRECISION
    //**************************************************************************************************
    //println!("{}=={}",0.1_f32+0.2_f32,0.3_f32);
    //println!("{}=={}",0.1 as f32+0.2 as f32,0.3 as f32);

    //**************************************************************************************************
    // CASE 07: FOR LOOP
    //**************************************************************************************************
    //let mut sum=0;
    //for i in 0..10{
    //    sum+=i;
    //    //println!("{}",i) // 0,1,...,9
    //};
    //let sigma=(10*9)/2;
    //println!("{}=={}",sum,sigma)

    //for i in 0..=10{
    //    println!("{}",i) // 0,1,...,10
    //};

    //for i in RangeInclusive::new(1, 5){
    //    println!("{}",i); // 1,2,...,5
    //};

    //**************************************************************************************************
    // CASE 08: RANGE AND RANGEINCLUSIVE
    //**************************************************************************************************
    // https://doc.rust-lang.org/std/ops/struct.Range.html
    // (3..5) == Range { start: 3, end: 5 }
    // assert_eq!((3..5), Range { start: 3, end: 5 });

    // https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html
    // assert_eq!((3..=5), RangeInclusive::new(3, 5));
    // assert_eq!(3 + 4 + 5, (3..=5).sum());

    // assert_eq!((1..=5), RangeInclusive::new(1, 5)); // Correct
    // assert_eq!((1..6), RangeInclusive::new(1, 5));  // Wrong

    //**************************************************************************************************
    // CASE 09: LAST EXAMPLE
    //**************************************************************************************************
    // Integer addition
    assert!(1u32 + 2 == 3u32);

    // Integer subtraction
    assert!(1i32 - 2 == -1i32);
    assert!(1i8 - 2 == -1); 
    
    assert!(3 * 50 == 150);

    assert!(9.6 / 3.2 == 3.0f32); // error ! make it work

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true && false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // Bitwise operations
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
 
1011101
 
1111101
 

T and T = T 
T and F = F
F and T = F
F and F = F
 
    for i in Range(1, 5){
 
std::ops::
 
sum+=i;
 
    let mut sum=0;
 
std::ops::
 
.to_string()
 
 RANGE
 
:f32
 
at matches size of a word in given platform.
 
 * It is a pointer type th
 
Method B
1. 
 

Method A
 
fn define_x() -> String {
    println!("// Initialize the Variable!");
    "hello".to_string()
}

 
    //**************************************************************************************************
    // CHAPTER 01: Variable
    //**************************************************************************************************
    /*
    Note
    1. end with ;
    2. Scope
     * # The Scope of the variable is defined by the block of code where it belong to.
    3. Shadowing
     * It is the process of create new variable with same scope and same name.
    4. Function
     * Reusable Code
    */
    //------------------------------------------------------------------------
    // SUB 01: BOOL
    //------------------------------------------------------------------------
    let che_truth: bool = true;
    let che_lyring: bool = false;
    let mut che_paradox: bool = true;
    che_paradox = false;

    //------------------------------------------------------------------------
    // SUB 02: STRING
    //------------------------------------------------------------------------
    let che_string: &str = "Hello";
    let che_char = 'c';
    // How to concat string?
    // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
    let mut che_mutstring: String = "Phuri".to_owned();
    let che_familyname = " Sottatipreedawong";
    che_mutstring.push_str(che_familyname);
    println!("");

    // What is the different between String and &str?
    // https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str

    //------------------------------------------------------------------------
    // SUB 03: NUMBER
    //------------------------------------------------------------------------
    /*
    Note
    1. The variable number cannot be larger than the largest number that have the same type.

    Set
    1. Z = integer
     * e.g. ...,-2,-1,0,1,2,... etc.
    2. N = natural number (include 0)
     * e.g. 0,1,2,3,... etc.
    3. Q = fractional number
     * e.g. 1/2, 3/8, 44/15 etc.


    Type
    1.  i8___ = -128        < x < 127
    2.  i16__ = -(327...+1) < x < 32767
    3.  i32__ = -(214...+1) < x < 2147483647
    4.  i64__ = -(922...+1) < x < 9223372036854775807
    5.  isize = -(922...+1) < x < 9223372036854775807
    6.  i128_ = -(170...+1) < x < 170141183460469231731687303715884105727
    7.  u8___ = -1 < x < 255
    8.  u16__ = -1 < x < 65535
    9.  u32__ = -1 < x < 4294967295
    10. u64__ = -1 < x < 18446744073709551615
    11. usize = -1 < x < 18446744073709551615
    12. u128_ = -1 < x < 340282366920938463463374607431768211455
    13. f32
     * single-precision float
     * MIN: -340282350000000000000000000000000000000
     * MAX: 340282350000000000000000000000000000000
    14. f64
     * double-precision float
     * MIM: -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
     * MAX: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    Note
    1. iN = -(2^N)/2 < x < (2^N)/2-1
    2. uN = -1 < x < 2^N

    */

    let che_i8: i8 = 112;
    let che_default_i: i32 = -666;
    let che_default_u: u32 = 999;
    let che_zero: u32 = 0;

    /*
    // let che_error_i8:i8=128;
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    */

    // println!("i8___:{}",i8::MAX);       // i8___: 127
    // println!("i16__:{}",i16::MAX);      // i16__: 32767
    // println!("i32__:{}",i32::MAX);      // i32__: 2147483647
    // println!("i64__:{}",i64::MAX);      // i64__: 9223372036854775807
    // println!("isize:{}",isize::MAX);    // isize: 9223372036854775807
    // println!("i128_:{}",i128::MAX);     // i128_: 170141183460469231731687303715884105727
    // println!("u8___:{}",u8::MAX);       // u8___: 255
    // println!("u16__:{}",u16::MAX);      // u16__: 65535
    // println!("u32__:{}",u32::MAX);      // u32__: 4294967295
    // println!("u64__:{}",u64::MAX);      // u64__: 18446744073709551615
    // println!("usize:{}",usize::MAX);    // usize: 18446744073709551615
    // println!("u128_:{}",u128::MIN);     // u128_: 340282366920938463463374607431768211455
    // println!("f32__:{}",f32::MIN);      // f32__: 340282350000000000000000000000000000000
    // println!("f64__:{}",f64::MIN);      // f64__: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    //**************************************************************************************************
    // SUB 04: FUNCTION
    //**************************************************************************************************
    // https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
    // let x:String=define_x();
    // println!("let x = {}",x);

    //**************************************************************************************************
    // SUB 05: SHADOW
    //**************************************************************************************************
    // let light:&str="Light";
    // println!("Original value: {}", light);
    // let light:&str="Shadow";
    // println!("Original value: {}", light);
    // let light:u8=100;
    //**************************************************************************************************
    // SUB 06: DESTRUCTURING
    //**************************************************************************************************
    // let (mut x, y) = (1, 2);
    // println!("{} == 1",x);
    // x += 2;
    // println!("{} == 3",x);

    //**************************************************************************************************
    // SUB 07: DECLARES MULTIPLE VARIABLES AT ONE LINE
    //**************************************************************************************************
    let (x, y, z, w)=(2,4,8,16);
 
https://youtu.be/ygL_xcavzQ4?si=fjGFFfamtpNByIw6
 

*************************************************
 
//*************************************************
 

//**************************************************************************************************
// SUB 06: SHADOW
 

// Rust
 
// Typescript
function define_x():string{
    return "hello"
}
 
/*
Question
1. What is the different between String and &str? 
2. What is the different between i32, u32 and f32?
3.
*/
 
let x = 
 
.to_string()
 
define_x
 
/*
i8___:-128
i16__:-32768
i32__:-2147483648
i64__:-9223372036854775808
isize:-9223372036854775808
i128_:-170141183460469231731687303715884105728
u8___:0
u16__:0
u32__:0
u64__:0
usize:0
u128_:0
*/
 
-1
 
 * MAX:
 
 = single
 
// Valid Code
 
-
 
.to_string()
 
che_mutstring+
 
.to_string()
 
Rule
1. let variable:type=value;
2. end with ;
3. Scope 
 * # The Scope of the variable is defined by the block of code where it belong to.
4. Shadowing
 * It is the process of create new variable with same scope and same name.
5. Function
 * Reusable Code
6. only variable that have `mut` is mutable
 
6. only variable that have `mut` is mutable
 
1. let variable:type=value;
 
//**************************************************************************************************
// Ch01
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
//**************************************************************************************************
    // mut = mutable
    /*
    let mut UserAnswer:String=String::new();
    println!("What is the value of e");
    let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
    println!("That is correct.");
    println!("The value of e is {}.", UserAnswer);
    // println!("no of bytes read , {}", b1);
    */
//**************************************************************************************************
//**************************************************************************************************
// Ch01: Data Type
// * https://www.codingame.com/playgrounds/365/getting-started-with-rust/primitive-data-types
//**************************************************************************************************
    let che_bool:bool=true;
    let che_char='c'; 
    // let che_Error_i8:i8=128; 
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    println!("i8___:{}",i8::MAX);       // i8___ = 127
    println!("i16__:{}",i16::MAX);      // i16__ = 32767
    println!("i32__:{}",i32::MAX);      // i32__ = 2147483647
    println!("i64__:{}",i64::MAX);      // i64__ = 9223372036854775807
    println!("isize:{}",isize::MAX);    // isize = 9223372036854775807
    println!("i128_:{}",i128::MAX);     // i128_ = 170141183460469231731687303715884105727
    println!("u8___:{}",u8::MAX);       // u8___ = 255
    println!("u16__:{}",u16::MAX);      // u16__ = 65535
    println!("u32__:{}",u32::MAX);      // u32__ = 4294967295
    println!("u64__:{}",u64::MAX);      // u64__ = 18446744073709551615
    println!("usize:{}",usize::MAX);    // usize = 18446744073709551615
    println!("u128_:{}",u128::MAX);     // u128_ = 340282366920938463463374607431768211455
    println!("f32__:{}",f32::MAX);      // f32__ = 340282350000000000000000000000000000000
    println!("f64__:{}",f64::MAX);      // f64__ = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
 
    */   
 
    /* 
 
    let che_i8:i8=12021;
 
    println!("u128::{}",u128::MAX);
    println!("u128::{}",u128::MAX);
 
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
 
// https://youtu.be/07pDD0uLjYc?si=Ar7cNF_yXScZjPTt
 
    let mut RealAnswer:Number=2.7
 

    /*
    
    println!("no of bytes read , {}", b1);
    */
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
let mut UserAnswer:String=String::new();
 
let mut UserAnswer:String=String::new();
 
The value of e{}", UserAnswer)
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
println!("Hello, {}",UserAnswer.trim_end());
 
println!("What is the value of e");
 
    let mut OnlyNumber:&str="This is not a number";
    let mut LessThan:&str="e is Less than";
    let mut GreaterThan:&str="e is Greater than";
 
world!
 
#![allow(unused)]
 
