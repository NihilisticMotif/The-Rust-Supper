.to_string()
 
:(i32,i32,(),&str)
 
.to_string()
 
.to_string()
 
x, 
 
, {}
 
    //let y = x;
 
//, y);
 

    // Use as many approaches as you can to make it work
 
    let s3 = 
 
    // might do other things
 
UNIT
 
Example No.2
 
: SCOPE
 
// 2. drop input previous ownership.
 
// copy the data with fixed size
 
Size of message is 24 bytes
 
"Hello" belong to Heap.
 
*/
 
|
|
|
 
 len
 
// Its pointer indicate the position of "Hello"
 
  
 
   //**************************************************************************************************
    // CASE 01: EXPRESSION
    //**************************************************************************************************

    //let x = 5u32;
    //let y = {
    //    let x_squared = x * x;
    //    let x_cube = x_squared * x;
    //    x_cube + x_squared + x
    //};
    //println!("x is {:?}", x);
    //println!("y is {:?}", y);

    //**************************************************************************************************
    // CASE 02
    //**************************************************************************************************
    // let v = {
    //    let mut x = 1;
    //    x + 2
    //    // x +=2 // is wrong
    // };
    // println!("{}",v);
    // let statement_v = {
    //    let mut x = 1;
    //    x += 2;
    //    // return unit type
    // };


    //**************************************************************************************************
    // CASE 03: MATCH
    //**************************************************************************************************
    let input=1;
    match input{
        1=>println!("low"),
        2=>println!("median"),
        3=>println!("high"),
        _ =>println!("Invalid")
    };

    //**************************************************************************************************
    // CASE 04: DIVERGE FUNCTION AND PANIC
    //**************************************************************************************************
    // never_return();

    //**************************************************************************************************
    // CASE 05: MATCH AND PANIC
    //**************************************************************************************************
    // let b = false;
    // let _v = match b {
    //     // return 1
    //     true => 1,
    //     // return error.
    //     false => {
    //         println!("Success!");
    //         panic!("we have no value for `false`, but we can panic");
    //     }
    // };
 
// This is diverge function
fn never_return() -> ! {
    // panic make the complier show error.
    panic!("SOS");
}

fn get_option(tp: u8) -> Option<i32> {
    match tp {
        1 => {
            // TODO
        }
        _ => {
            // TODO
        }
    };
    
    // Rather than returning a None, we use a diverging function instead
    never_return_fn()
}

// IMPLEMENT this function in THREE ways
fn never_return_fn() -> ! {
    panic!("SOS");
    //unimplemented!();
    //todo!();
}

 
// Diverging functions can also be used in match expression to replace a value of any value
 
the fn signatures
 
    // Implement this function, don't modify 
 
"This function never returns!"
 
//
 
    println!("z is {:?}", z);
 
    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x
    };
 

        // This expression will be assigned to `y`
 
fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}

fn implicitly_ret_unit() {
    println!("I will return a ()");
}

// Don't use this one
fn explicitly_ret_unit() -> () {
    println!("I will return a ()");
}

// Explicitly return i32
fn one984(justthe:i32,two:i32)->i32{
    let ofus:i32=1;
    justthe+two+ofus
}
 
    //**************************************************************************************************
    // CASE 01: SIZE OF CHAR IS 4
    //**************************************************************************************************

    // let c1 = 'a';
    // let c2 = 'ä¸­';
    // println!("bit size of c1 = {}",size_of_val(&c1)); // 4
    // println!("bit size of c2 = {}",size_of_val(&c2)); // 4

    //**************************************************************************************************
    // CASE 02: SINGLE QUOTE = CHAR , DOUBLE QUOTE = &STR
    //**************************************************************************************************
    // let c1:char='a';
    // let c2:&str="a";
    // println!("Type of c1 = {}",type_of(&c1));   // char
    // println!("Type of c2 = {}",type_of(&c2));   // &str

    //**************************************************************************************************
    // CASE 03: CONDITION
    //**************************************************************************************************

    // let thetruth:bool=true;
    // //let thetruth:bool=false;
    // let myname:&str="CheChe";
    // if myname=="Cheche"{
    //     println!("God.");
    // }
    // else{
    //     println!("Satan.");
    // };

    //**************************************************************************************************
    // CASE 03: AND
    //**************************************************************************************************
    // let f = false;
    // let t = true && false;
    // println!("{} == {}",f,t);

    //**************************************************************************************************
    // CASE 04: UNIT TYPE
    //**************************************************************************************************
    // The unit type is the data type that have 0 bits.
    // The function that does not return any value
    // will always return unit type.
    // let emptyset: () = (); 
    let tuplee: (i32,i32,i32)=(22,23,24);
    // println!("{}",one984(2,2));

    //**************************************************************************************************
    // CASE 05: SIZE OF UNIT TYPE
    //**************************************************************************************************
    let unit: () = ();
    println!("{}",size_of_val(&unit));  // 0
 
,thetruth
 
 tell {}
 
,thetruth
 
//let y: &[u8] = &x;
 
 and {}
 

fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}
 
    //**************************************************************************************************
    // CASE 01: ASSIGNED VALUE AS TYPE
    //**************************************************************************************************

    //#v = 38 that is assigned as u16
    //#38 is assigned as u8
    //let v: u16 = 38_u8 as u16;

    //println!("Success!");

    //**************************************************************************************************
    // CASE 02: DEFAULT VALUE
    //**************************************************************************************************
    // let x = 5;
    // println!("{}=={}",
    //     "i32".to_string(), 
    //     type_of(&x).to_string());

    //**************************************************************************************************
    // CASE 03: CHECKED_ADD AND UNWRAP
    //**************************************************************************************************
    // let v1 = 251_u16 + 8;
    // let v2 = i16::checked_add(251, 8).unwrap();
    // println!("{},{}",v1,v2);

    //**************************************************************************************************
    // CASE 04: 0XFF
    //**************************************************************************************************
    //#hexadecimal numeral system
    // println!("0xff = {}",0xff); // = 255
    // println!("0o77 = {}",0o77); // = 63
    // println!("0b1111_1111 = {}",0b1111_1111); // = 255

    //**************************************************************************************************
    // CASE 05: FLOATING POINT
    //**************************************************************************************************
    //let x64 = 1_000.000_1;
    //println!("{}==f64",type_of(&x64));

    //**************************************************************************************************
    // CASE 06: FLOATING POINT PRECISION
    //**************************************************************************************************
    //println!("{}=={}",0.1_f32+0.2_f32,0.3_f32);
    //println!("{}=={}",0.1 as f32+0.2 as f32,0.3 as f32);

    //**************************************************************************************************
    // CASE 07: FOR LOOP
    //**************************************************************************************************
    //let mut sum=0;
    //for i in 0..10{
    //    sum+=i;
    //    //println!("{}",i) // 0,1,...,9
    //};
    //let sigma=(10*9)/2;
    //println!("{}=={}",sum,sigma)

    //for i in 0..=10{
    //    println!("{}",i) // 0,1,...,10
    //};

    //for i in RangeInclusive::new(1, 5){
    //    println!("{}",i); // 1,2,...,5
    //};

    //**************************************************************************************************
    // CASE 08: RANGE AND RANGEINCLUSIVE
    //**************************************************************************************************
    // https://doc.rust-lang.org/std/ops/struct.Range.html
    // (3..5) == Range { start: 3, end: 5 }
    // assert_eq!((3..5), Range { start: 3, end: 5 });

    // https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html
    // assert_eq!((3..=5), RangeInclusive::new(3, 5));
    // assert_eq!(3 + 4 + 5, (3..=5).sum());

    // assert_eq!((1..=5), RangeInclusive::new(1, 5)); // Correct
    // assert_eq!((1..6), RangeInclusive::new(1, 5));  // Wrong

    //**************************************************************************************************
    // CASE 09: LAST EXAMPLE
    //**************************************************************************************************
    // Integer addition
    assert!(1u32 + 2 == 3u32);

    // Integer subtraction
    assert!(1i32 - 2 == -1i32);
    assert!(1i8 - 2 == -1); 
    
    assert!(3 * 50 == 150);

    assert!(9.6 / 3.2 == 3.0f32); // error ! make it work

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true && false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // Bitwise operations
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
 
1011101
 
1111101
 

T and T = T 
T and F = F
F and T = F
F and F = F
 
    for i in Range(1, 5){
 
std::ops::
 
sum+=i;
 
    let mut sum=0;
 
std::ops::
 
.to_string()
 
 RANGE
 
:f32
 
at matches size of a word in given platform.
 
 * It is a pointer type th
 
Method B
1. 
 

Method A
 
fn define_x() -> String {
    println!("// Initialize the Variable!");
    "hello".to_string()
}

 
    //**************************************************************************************************
    // CHAPTER 01: Variable
    //**************************************************************************************************
    /*
    Note
    1. end with ;
    2. Scope
     * # The Scope of the variable is defined by the block of code where it belong to.
    3. Shadowing
     * It is the process of create new variable with same scope and same name.
    4. Function
     * Reusable Code
    */
    //------------------------------------------------------------------------
    // SUB 01: BOOL
    //------------------------------------------------------------------------
    let che_truth: bool = true;
    let che_lyring: bool = false;
    let mut che_paradox: bool = true;
    che_paradox = false;

    //------------------------------------------------------------------------
    // SUB 02: STRING
    //------------------------------------------------------------------------
    let che_string: &str = "Hello";
    let che_char = 'c';
    // How to concat string?
    // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
    let mut che_mutstring: String = "Phuri".to_owned();
    let che_familyname = " Sottatipreedawong";
    che_mutstring.push_str(che_familyname);
    println!("");

    // What is the different between String and &str?
    // https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str

    //------------------------------------------------------------------------
    // SUB 03: NUMBER
    //------------------------------------------------------------------------
    /*
    Note
    1. The variable number cannot be larger than the largest number that have the same type.

    Set
    1. Z = integer
     * e.g. ...,-2,-1,0,1,2,... etc.
    2. N = natural number (include 0)
     * e.g. 0,1,2,3,... etc.
    3. Q = fractional number
     * e.g. 1/2, 3/8, 44/15 etc.


    Type
    1.  i8___ = -128        < x < 127
    2.  i16__ = -(327...+1) < x < 32767
    3.  i32__ = -(214...+1) < x < 2147483647
    4.  i64__ = -(922...+1) < x < 9223372036854775807
    5.  isize = -(922...+1) < x < 9223372036854775807
    6.  i128_ = -(170...+1) < x < 170141183460469231731687303715884105727
    7.  u8___ = -1 < x < 255
    8.  u16__ = -1 < x < 65535
    9.  u32__ = -1 < x < 4294967295
    10. u64__ = -1 < x < 18446744073709551615
    11. usize = -1 < x < 18446744073709551615
    12. u128_ = -1 < x < 340282366920938463463374607431768211455
    13. f32
     * single-precision float
     * MIN: -340282350000000000000000000000000000000
     * MAX: 340282350000000000000000000000000000000
    14. f64
     * double-precision float
     * MIM: -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
     * MAX: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    Note
    1. iN = -(2^N)/2 < x < (2^N)/2-1
    2. uN = -1 < x < 2^N

    */

    let che_i8: i8 = 112;
    let che_default_i: i32 = -666;
    let che_default_u: u32 = 999;
    let che_zero: u32 = 0;

    /*
    // let che_error_i8:i8=128;
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    */

    // println!("i8___:{}",i8::MAX);       // i8___: 127
    // println!("i16__:{}",i16::MAX);      // i16__: 32767
    // println!("i32__:{}",i32::MAX);      // i32__: 2147483647
    // println!("i64__:{}",i64::MAX);      // i64__: 9223372036854775807
    // println!("isize:{}",isize::MAX);    // isize: 9223372036854775807
    // println!("i128_:{}",i128::MAX);     // i128_: 170141183460469231731687303715884105727
    // println!("u8___:{}",u8::MAX);       // u8___: 255
    // println!("u16__:{}",u16::MAX);      // u16__: 65535
    // println!("u32__:{}",u32::MAX);      // u32__: 4294967295
    // println!("u64__:{}",u64::MAX);      // u64__: 18446744073709551615
    // println!("usize:{}",usize::MAX);    // usize: 18446744073709551615
    // println!("u128_:{}",u128::MIN);     // u128_: 340282366920938463463374607431768211455
    // println!("f32__:{}",f32::MIN);      // f32__: 340282350000000000000000000000000000000
    // println!("f64__:{}",f64::MIN);      // f64__: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    //**************************************************************************************************
    // SUB 04: FUNCTION
    //**************************************************************************************************
    // https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
    // let x:String=define_x();
    // println!("let x = {}",x);

    //**************************************************************************************************
    // SUB 05: SHADOW
    //**************************************************************************************************
    // let light:&str="Light";
    // println!("Original value: {}", light);
    // let light:&str="Shadow";
    // println!("Original value: {}", light);
    // let light:u8=100;
    //**************************************************************************************************
    // SUB 06: DESTRUCTURING
    //**************************************************************************************************
    // let (mut x, y) = (1, 2);
    // println!("{} == 1",x);
    // x += 2;
    // println!("{} == 3",x);

    //**************************************************************************************************
    // SUB 07: DECLARES MULTIPLE VARIABLES AT ONE LINE
    //**************************************************************************************************
    let (x, y, z, w)=(2,4,8,16);
 
https://youtu.be/ygL_xcavzQ4?si=fjGFFfamtpNByIw6
 

*************************************************
 
//*************************************************
 

//**************************************************************************************************
// SUB 06: SHADOW
 

// Rust
 
// Typescript
function define_x():string{
    return "hello"
}
 
/*
Question
1. What is the different between String and &str? 
2. What is the different between i32, u32 and f32?
3.
*/
 
let x = 
 
.to_string()
 
define_x
 
/*
i8___:-128
i16__:-32768
i32__:-2147483648
i64__:-9223372036854775808
isize:-9223372036854775808
i128_:-170141183460469231731687303715884105728
u8___:0
u16__:0
u32__:0
u64__:0
usize:0
u128_:0
*/
 
-1
 
 * MAX:
 
 = single
 
// Valid Code
 
-
 
.to_string()
 
che_mutstring+
 
.to_string()
 
Rule
1. let variable:type=value;
2. end with ;
3. Scope 
 * # The Scope of the variable is defined by the block of code where it belong to.
4. Shadowing
 * It is the process of create new variable with same scope and same name.
5. Function
 * Reusable Code
6. only variable that have `mut` is mutable
 
6. only variable that have `mut` is mutable
 
1. let variable:type=value;
 
//**************************************************************************************************
// Ch01
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
//**************************************************************************************************
    // mut = mutable
    /*
    let mut UserAnswer:String=String::new();
    println!("What is the value of e");
    let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
    println!("That is correct.");
    println!("The value of e is {}.", UserAnswer);
    // println!("no of bytes read , {}", b1);
    */
//**************************************************************************************************
//**************************************************************************************************
// Ch01: Data Type
// * https://www.codingame.com/playgrounds/365/getting-started-with-rust/primitive-data-types
//**************************************************************************************************
    let che_bool:bool=true;
    let che_char='c'; 
    // let che_Error_i8:i8=128; 
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    println!("i8___:{}",i8::MAX);       // i8___ = 127
    println!("i16__:{}",i16::MAX);      // i16__ = 32767
    println!("i32__:{}",i32::MAX);      // i32__ = 2147483647
    println!("i64__:{}",i64::MAX);      // i64__ = 9223372036854775807
    println!("isize:{}",isize::MAX);    // isize = 9223372036854775807
    println!("i128_:{}",i128::MAX);     // i128_ = 170141183460469231731687303715884105727
    println!("u8___:{}",u8::MAX);       // u8___ = 255
    println!("u16__:{}",u16::MAX);      // u16__ = 65535
    println!("u32__:{}",u32::MAX);      // u32__ = 4294967295
    println!("u64__:{}",u64::MAX);      // u64__ = 18446744073709551615
    println!("usize:{}",usize::MAX);    // usize = 18446744073709551615
    println!("u128_:{}",u128::MAX);     // u128_ = 340282366920938463463374607431768211455
    println!("f32__:{}",f32::MAX);      // f32__ = 340282350000000000000000000000000000000
    println!("f64__:{}",f64::MAX);      // f64__ = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
 
    */   
 
    /* 
 
    let che_i8:i8=12021;
 
    println!("u128::{}",u128::MAX);
    println!("u128::{}",u128::MAX);
 
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
 
// https://youtu.be/07pDD0uLjYc?si=Ar7cNF_yXScZjPTt
 
    let mut RealAnswer:Number=2.7
 

    /*
    
    println!("no of bytes read , {}", b1);
    */
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
let mut UserAnswer:String=String::new();
 
let mut UserAnswer:String=String::new();
 
The value of e{}", UserAnswer)
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
println!("Hello, {}",UserAnswer.trim_end());
 
println!("What is the value of e");
 
    let mut OnlyNumber:&str="This is not a number";
    let mut LessThan:&str="e is Less than";
    let mut GreaterThan:&str="e is Greater than";
 
world!
 
#![allow(unused)]
 
