// use std::fmt::{self, Debug};
// https://prince.dev/debug-struct
// https://youtu.be/BpPEoZW5IiY?si=goDW5z6qEkPok4pe
// use std::fmt;
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
struct A;          // Concrete type `A`.
struct S(A);       // Concrete type `S`.
struct SGen<T>(T); // Generic type `SGen`.

fn reg_fn(_s: S) {}

fn gen_spec_t(_s: SGen<A>) {}

fn gen_spec_i32(_s: SGen<i32>) {}

fn generic<T>(_s: SGen<T>) {}

 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
// Using the non-generic functions
reg_fn(S(A));          // Concrete type.
gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
gen_spec_i32(SGen(4)); // Implicitly specified type parameter `i32`.
// Explicitly specified type parameter `char` to `generic()`.
generic::<char>(SGen('a'));
// Implicitly specified type parameter `char` to `generic()`.
generic(SGen('a'));
println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

 
// let rect1 = Rectangle01 { width: 30, height: 50 };
// assert_eq!(rect1.area(), 1500);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1.2 PRINTLN STRUCT AND ARRAY
//**************************************************************************************************
// let origin = [1,2,3];
// println!("The origin is: {:?}", origin);
// let origin = Point { x: 0, y: 0 };
// println!("The origin is: {:?}", origin);    // Error

//**************************************************************************************************
// EXAMPLE NO.2 &SELF
//**************************************************************************************************
// let light = TrafficLight02{
//     color: "red".to_owned(),
// };
// light.show_state();
// println!("{:#?}", light);

//**************************************************************************************************
// EXAMPLE NO.3 &MUT SELF
//**************************************************************************************************
// let mut light = TrafficLight02{
//     color: "red".to_owned(),
// };
// light.show_state();
// println!("{:#?}", light);
// light.change_state("Orange".to_string());
// println!("{:#?}", light);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
// let light = TrafficLight04::new();
// assert_eq!(light.get_state(), "red");
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.5 MATHOD TAKES 2 INSTANCE
//**************************************************************************************************
// let aaa=Rectangle05{width:10,height:20};
// let a=Rectangle05{width:5,height:5};
// println!("{}",aaa.can_hold(&a));


//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let c = TrafficLightColor::Yellow;
// assert_eq!(c.color(), "yellow");
// println!("{:?}",c);
 
//#[derive(Debug)] // used for debugging
 

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
#[derive(Debug)] 
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
impl TrafficLight02 {
    pub fn change_state(&mut self, new_color:String) {
        self.color = new_color
    }
}
#[derive(Debug)] 
struct Point {
    x: i32,
    y: i32,
}

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************

#[derive(Debug)]
struct TrafficLight04 {
    color: String,
}
// `Self` refers to the current type that implements a trait, 
// `self` on the other hand refers to the instance.
// https://stackoverflow.com/questions/32304595/whats-the-difference-between-self-and-self
impl TrafficLight04 {
    pub fn new()->Self{
    // pub fn new()->TrafficLight04{
        Self {
        // TrafficLight04 {
            color: "red".to_string(),
        }
    }

    pub fn get_state(&self) -> &str {
        &self.color
    }
}


//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
#[derive(Debug)]

struct Rectangle05 {
    width: u32,
    height: u32,
}

impl Rectangle05 {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Self) -> bool {
        self.width > other.width && self.height > other.height
    }
}


//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

// Implement TrafficLightColor with a method.
impl TrafficLightColor {
    fn color(&self)->String{
        match self{
            // TrafficLightColor::Red=>"red".to_string(),
            Self::Red=>"red".to_string(),
            Self::Yellow=>"yellow".to_string(),
            Self::Green=>"green".to_string(),
        }
    }
}

 
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
 
    pub fn change_state(&mut self, new_color:String) {
        self.color = new_color
    }
 

    pub fn get_state(&self) -> &str {
        &self.color
    }
 
    pub fn new()->Self{
    // pub fn new()->TrafficLight04{
        Self {
        // TrafficLight04 {
            color: "red".to_string(),
        }
    }
 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

 
    // 1. Implement an associated function `new`,
    // 2. It will return a TrafficLight contains color "red"
    // 3. Must use `Self`, DONT use `TrafficLight` in fn signatures or body
 
show_state();
 
 METHOD
 
#[derive(Debug)] 
struct TrafficLight03 {
    color: String,
}

impl TrafficLight03 {
    // Using `Self` to fill in the blank.
    pub fn show_state(&self)  {
        println!("the current state is {}", self.color);
    }

    // Fill in the blank, DON'T use any variants of `Self`.
    pub fn change_state(&mut self) {
        self.color = "green".to_string()
    }
}

 
println!("{:#?}", light);
 
// ... Otherwise, there will be an error below
//let light=light;
//println!("{:?}", light);
 
// Don't take the ownership of `light` here.
 
/*
// I get this error
error[E0277]: `TrafficLight02` doesn't implement `Debug`
  --> src/main.rs:39:22
   |
39 |     println!("{:?}", light);
   |                      ^^^^^ `TrafficLight02` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `TrafficLight02`
   = note: add `#[derive(Debug)]` to `TrafficLight02` or manually `impl Debug for TrafficLight02`
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider annotating `TrafficLight02` with `#[derive(Debug)]`
   |
16 + #[derive(Debug)]
17 | struct TrafficLight02 {
   |
 */
 
Cargo.toml

[package]
name = "the_rust_supper"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
I use MacOS version 12.6.7 and VSCode. Why there is the error? How can I fix it?

imac@iMacs-iMac the_rust_supper % rustc --version
rustc 1.75.0 (82e1608df 2023-12-21)
 
#![allow(unused)]
#[derive(Debug)] // used for debugging
// use std::fmt::{self, Debug};
// https://prince.dev/debug-struct
// https://youtu.be/BpPEoZW5IiY?si=goDW5z6qEkPok4pe
// use std::fmt;
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
#[derive(Debug)] 
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
#[derive(Debug)] 
struct Point {
    x: i32,
    y: i32,
}
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

fn main() {
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
// let rect1 = Rectangle01 { width: 30, height: 50 };
// assert_eq!(rect1.area(), 1500);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1.2 PRINTLN STRUCT AND ARRAY
//**************************************************************************************************
// let origin = [1,2,3];
// println!("The origin is: {:?}", origin);
// let origin = Point { x: 0, y: 0 };
// println!("The origin is: {:?}", origin);    // Error

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
let light = TrafficLight02{
    color: "red".to_owned(),
};
println!("{:#?}", light);
// Don't take the ownership of `light` here.
light.show_state();
// ... Otherwise, there will be an error below
//let light=light;
//println!("{:?}", light);

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

}

/*
cargo run
*/
 
/*
cargo run
*/
 

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}
 
TrafficLight0
 

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        println!("the current state is {}", self.color);
    }
}
 
struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}
 
struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}
 
// use std::fmt::{self, Debug};
// https://prince.dev/debug-struct
// https://youtu.be/BpPEoZW5IiY?si=goDW5z6qEkPok4pe
// use std::fmt;
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

 

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
// let rect1 = Rectangle01 { width: 30, height: 50 };
// assert_eq!(rect1.area(), 1500);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1.2 PRINTLN STRUCT AND ARRAY
//**************************************************************************************************
// let origin = [1,2,3];
// println!("The origin is: {:?}", origin);
// let origin = Point { x: 0, y: 0 };
// println!("The origin is: {:?}", origin);    // Error

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
 
//let light=light;
 
println!("{:#?}", light);
 
        let text=&self.color;
 
    // println!("{}", peter); // <- Error
 
    // Pretty print
 
struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}
 
let origin:Point = Point { x: 0, y: 0 };
println!("The origin is: {:?}", origin);   
 
<'a>
 
/**
// I get this error
error[E0277]: `Point` doesn't implement `Debug`
  --> src/main.rs:33:34
   |
33 | println!("The origin is: {:#?}", origin);    
   |                                  ^^^^^^ `Point` cannot be formatted using `{:?}`
   |
   = help: the trait `Debug` is not implemented for `Point`
   = note: add `#[derive(Debug)]` to `Point` or manually `impl Debug for Point`
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider annotating `Point` with `#[derive(Debug)]`
   |
24 + #[derive(Debug)]
25 | struct Point {
   |
 */ 
 
// Why there is the error in println?
 
//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
 

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
 
// Error
 
struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
 
//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
let light = TrafficLight02{
    color: "red".to_owned(),
};
println!("{:#?}", light);
// Don't take the ownership of `light` here.
light.show_state();
 
// ... Otherwise, there will be an error below
//let light=light;
//println!("{:?}", light);

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

 
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
// let rect1 = Rectangle01 { width: 30, height: 50 };
// assert_eq!(rect1.area(), 1500);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1.2 PRINTLN STRUCT AND ARRAY
//**************************************************************************************************
// let origin = [1,2,3];
// println!("The origin is: {:?}", origin);
 
struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
 
// 
 
#![allow(unused)]
#[derive(Debug)] // used for debugging
 
#![allow(unused)]
#[derive(Debug)] // used for debugging
// use std::fmt::{self, Debug};
// https://prince.dev/debug-struct
// https://youtu.be/BpPEoZW5IiY?si=goDW5z6qEkPok4pe
// use std::fmt;
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

struct Rectangle01{
    width: u32,
    height: u32,
}

impl Rectangle01 {
    // Complete the area method which return the area of a Rectangle.
    fn area(&self)->u32{
        self.width*self.height
    }
}

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
struct TrafficLight02 {
    color: String,
}

impl TrafficLight02 {
    pub fn show_state(&self)  {
        let text=&self.color;
        println!("the current state is {}", text);
    }
}
struct Point {
    x: i32,
    y: i32,
}
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

fn main() {
//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************
// let rect1 = Rectangle01 { width: 30, height: 50 };
// assert_eq!(rect1.area(), 1500);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.1.2 PRINTLN STRUCT AND ARRAY
//**************************************************************************************************
// let origin = [1,2,3];
// println!("The origin is: {:?}", origin);
// let origin = Point { x: 0, y: 0 };
// println!("The origin is: {:?}", origin);    // Error

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
let light = TrafficLight02{
    color: "red".to_owned(),
};
println!("{:#?}", light);
// Don't take the ownership of `light` here.
light.show_state();
// ... Otherwise, there will be an error below
//let light=light;
//println!("{:?}", light);

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.1 METHOD
//**************************************************************************************************

}

/*
cargo run
*/
 
// 
 
write!("{}",
 
)
 
let origin = Point { x: 0, y: 0 };
 
Point { x: 0, y: 0 };
 
Debug = "0.1.1"
 
format!("{:?}",
 
// 
 
format!("{:?}",
 
to_owned()
 
// 
 
_
 

//**************************************************************************************************
// FUNCTION NO.1
//**************************************************************************************************
fn match_number01(n: i32) {
    match n {
        // Match a single value
        1 => println!("One!"),
        // Fill in the blank with `|`, DON'T use `..` or `..=`
        2..=5 => println!("match 2 -> 5"),
        // Match an inclusive range
        6..=10 => {
            println!("match 6 -> 10")
        },
        _ => {
            println!("match -infinite -> 0 or 11 -> +infinite")
        }
    }
}
//**************************************************************************************************
// STRUCT NO.2
//**************************************************************************************************
struct Point02 {
    x: i32,
    y: i32,
}

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
enum Message03 {
    Hello { id: i32 },
}

fn match_message03(msg:Message03)->(){
match msg {
    Message03::Hello {
        id:  id@3..=7
    } => println!("Found an id in range [3, 7]: {}", id),
    Message03::Hello { id: newid@(10 | 11 | 12) } => {
        println!("Found an id in another range [10, 12]: {}", newid)
    }
    Message03::Hello { id:i } => println!("Found some other id: {}", i),
}
}

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

 
// match_number01(-11);
// match_number01(2);
// match_number01(5);
// match_number01(6);
// match_number01(8);
// match_number01(88);

//**************************************************************************************************
// EXAMPLE NO.2 @ (AT SIGN)
//**************************************************************************************************
// let p = Point02 { x: 1, y: 10 };
// match p {
//     Point02 { x, y: 0 } => println!("On the x axis at {}", x),
//     // Second arm
//     Point02 { x: 0..=5, y: y@ (10 | 20 | 30) } => println!("On the y axis at {}", y),
//     Point02 { x, y } => println!("On neither axis: ({}, {})", x, y),
// }

//**************************************************************************************************
// EXAMPLE NO.3 IN (CHECK IF THE VALUE WITHIN THE SET) OF MATCH
//**************************************************************************************************
// let msg = Message03::Hello { id: 5 };
// match_message03(msg);
// let msg = Message03::Hello { id: 10 };
// match_message03(msg);
// let msg = Message03::Hello { id: 500 };
// match_message03(msg);

//**************************************************************************************************
// EXAMPLE NO.4 CONDITION IN MATCH SOME
//**************************************************************************************************
// let num = Some(4);
// let split = 5;
// match num {
//     // https://stackoverflow.com/questions/47852269/can-i-use-and-in-match
//     Some(x) if x<split => assert!(x < split),
//     Some(x) => assert!(x >= split),
//     None => (),
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
//// Because a tuple is technically a struct, we cannot iterate over its elements in a loop.
//// If we want a data container that can be iterated over,
//// it would be better to store our data into an array or a collection (like a HashMap ).
//// https://www.koderhq.com/tutorial/rust/tuple/#loop
//// Because tuple are struct, the size of tuple cannot be access.
//// In Rust, the maximum size of tuple is 13.
// let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);
// println!("The first element = {}",numbers.0);
// let (first,last) = (numbers.0,numbers.10);
// match numbers {
//     numbers if numbers.0==2 && numbers.10==2048 => {
//         let first=numbers.0;
//         let last=numbers.10;
//        assert_eq!(first, 2);
//        assert_eq!(last, 2048);
//     }
//     _=>()
// }
// match numbers {
//     (first,.., last) if numbers.0==2 && numbers.10==2048 => {
//        assert_eq!(first, 2);
//        assert_eq!(last, 2048);
//     }
//     _=>()
// }
//     println!("Success!");
// match numbers {
//     (first,.., last) => {
//        assert_eq!(first, 2);
//        assert_eq!(last, 2048);
//     }
//     _=>()
// }
//     println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let mut v = String::from("hello,");
// let r = &mut v;
// let mut text="".to_string();
// match r {
//     // value:&mut String
//     value => {
//     value.push_str(" world!");
//     text=value.to_string();
// }
// }
// println!("{}",text);

 
if numbers.0==2 && numbers.10==2048
 
 if numbers.0==2 && numbers.10==2048 
 
numbers
 
        let first=numbers.0;
        let last=numbers.10;
 
// 
 
.Copy()
 
println!("{}",r);
 
//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

 
println!("length = {}",numbers.0);
println!("length = {}",numbers.10);
 
//
 
println!("length = {}",first);
println!("length = {}",last);
 
,number.10:last
 
numbers:(first,numbers.1 ..=numbers.9,last)
 
:(first,last)(numbers.0,numbers.10)
 
//println!("The last  element = {:?}",numbers.len);
 
for i in numbers{
    println!("{}",i);
}
 
for i in numbers.iter(){
    println("{}",i);
}
 
last(
 
 if x>=split
 
x<split
 
let nn=32;
 
    println!("n = {}",n);
 
fn match_number(n: i32)->(){
    println!("n = {}",n);
    //match n {
    //    // Match a single value
    //    1 => println!("One!"),
    //    // Fill in the blank with `|`, DON'T use `..` or `..=`
    //    //__ => println!("match 2 -> 5"),
    //    // Match an inclusive range
    //    // 6..=10 => {
    //    //     println!("match 6 -> 10")
    //    // },
    //    _ => {
    //        println!("match -infinite -> 0 or 11 -> +infinite")
    //    }
    //}
}
 
 as i32
 
//**************************************************************************************************
// FUNCTION NO.1
//**************************************************************************************************
fn match_number01(n: i32) {
    match n {
        // Match a single value
        1 => println!("One!"),
        // Fill in the blank with `|`, DON'T use `..` or `..=`
        2..=5 => println!("match 2 -> 5"),
        // Match an inclusive range
        6..=10 => {
            println!("match 6 -> 10")
        },
        _ => {
            println!("match -infinite -> 0 or 11 -> +infinite")
        }
    }
}
//**************************************************************************************************
// STRUCT NO.2
//**************************************************************************************************
struct Point02 {
    x: i32,
    y: i32,
}

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
enum Message03 {
    Hello { id: i32 },
}

fn match_message03(msg:Message03)->(){
match msg {
    Message03::Hello {
        id:  id@3..=7
    } => println!("Found an id in range [3, 7]: {}", id),
    Message03::Hello { id: newid@(10 | 11 | 12) } => {
        println!("Found an id in another range [10, 12]: {}", newid)
    }
    Message03::Hello { id:i } => println!("Found some other id: {}", i),
}
}

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

 

/*
cargo run
*/
 

//**************************************************************************************************
// EXAMPLE NO.1 MATCH INTEGER WITHIN THE RANGE.
//**************************************************************************************************
// match_number01(-11);
// match_number01(2);
// match_number01(5);
// match_number01(6);
// match_number01(8);
// match_number01(88);

//**************************************************************************************************
// EXAMPLE NO.2 @ (AT SIGN)
//**************************************************************************************************
// let p = Point02 { x: 1, y: 10 };
// match p {
//     Point02 { x, y: 0 } => println!("On the x axis at {}", x),
//     // Second arm
//     Point02 { x: 0..=5, y: y@ (10 | 20 | 30) } => println!("On the y axis at {}", y),
//     Point02 { x, y } => println!("On neither axis: ({}, {})", x, y),
// }

//**************************************************************************************************
// EXAMPLE NO.3 IN (CHECK IF THE VALUE WITHIN THE SET) OF MATCH
//**************************************************************************************************
// let msg = Message03::Hello { id: 5 };
// match_message03(msg);
// let msg = Message03::Hello { id: 10 };
// match_message03(msg);
// let msg = Message03::Hello { id: 500 };
// match_message03(msg);

//**************************************************************************************************
// EXAMPLE NO.4 CONDITION IN MATCH SOME
//**************************************************************************************************
// let num = Some(4);
// let split = 5;
// match num {
//     // https://stackoverflow.com/questions/47852269/can-i-use-and-in-match
//     Some(x) if x<split => assert!(x < split),
//     Some(x) => assert!(x >= split),
//     None => (),
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);
println("The first element = {}",numbers.0);
println("The first element = {}",numbers.-1);
// match numbers {
//     numbers:first@numbers.0 && => {
//        assert_eq!(first, 2);
//        assert_eq!(last, 2048);
//     }
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************

 
Note 
1. When deal with for loop, 
 * if the collection variable is immutable, it is automatically copy, so do not worry about it. 
 * if the collection variable is mutable, then reference (&) it, or clone it (recomment reference)
 
 conditional
 
println!("{}",numbers.0);
 


// match msg {
//     Message03::Hello {id:3} => {
//         println!("id == 3")
//     },
//     Message03::Hello {id:i} => println!("id != 3"),
// }
 
match msg {
    Message03::Hello {
        id:  id@3..=7
    } => println!("Found an id in range [3, 7]: {}", id),
    Message03::Hello { id: id@(10 | 11 | 12) } => {
        println!("Found an id in another range [10, 12]: {}", id)
    }
    Message03::Hello { id:i } => println!("Found some other id: {}", i),
}
 
(10 | 11 | 12)
 

// match msg {
//     Message03::Hello {id:3} => {
//         println!("id == 3")
//     },
//     Message03::Hello {id:i} => println!("id != 3"),
// }

 
let msg = Message::Hello { id: 5 };
 
"Found some other id: {}", id
 
Found an id in range [3, 7]: {}", id
 
    Message03::Hello { id: newid@10 | 11 | 12 } => {
        println!("Found an id in another range [10, 12]: {}", newid)
    }
 
    
 
        
 
// Fill in the blank to let p match the second arm
 
fn match_number(n: i32) {
    match n {
        // Match a single value
        1 => println!("One!"),
        // Fill in the blank with `|`, DON'T use `..` or `..=`
        __ => println!("match 2 -> 5"),
        // Match an inclusive range
        6..=10 => {
            println!("match 6 -> 10")
        },
        _ => {
            println!("match -infinite -> 0 or 11 -> +infinite")
        }
    }
}
 
//**************************************************************************************************
// ENUM NO.1
//**************************************************************************************************
enum Direction01 {
    East    ,
    West    ,
    North   ,
    South   ,
}

//**************************************************************************************************
// FUNCTION NO.2
//**************************************************************************************************
fn boolto01f02(b:bool)->u8{
    match b{
        true=>1,
        _=>0
    }
}

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
fn show_message03(msg: Message03) {
    match msg {
        Message03::Move{x:a,y:b} => { // match  Message::Move
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message03::ChangeColor(r, g, b) => {
            assert_eq!(g, 255);
            assert_eq!(b, 0);
        }
        _ => println!("no data in these variants")
    }
}
enum Message03 {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}


//**************************************************************************************************
// ENUM NO.5
//**************************************************************************************************
enum MyEnum05 {
    Foo,
    Bar
}

//**************************************************************************************************
// ENUM NO.7
//**************************************************************************************************
enum Foo07 {
    Bar(u8)
}

//**************************************************************************************************
// ENUM NO.8
//**************************************************************************************************
enum Foo08 {
    Bar,
    Baz,
    Qux(u32)
}

//**************************************************************************************************
// MAIN
//**************************************************************************************************

 
/**************************************************************************************************
// EXAMPLE NO.1 MATCH ENUM
//**************************************************************************************************
// let dire = Direction01::South;
// if let dire {
//     Direction01::East => println!("East"),
//     (Direction01::South|Direction01::North)  => { // Matching South or North here
//         println!("South or North");
//     },
//     _ => (),
// };

//**************************************************************************************************
// EXAMPLE NO.2 MATCH BOOLEAN TO U8
//**************************************************************************************************
// let booleann = true;
// let binary = boolto01f02(booleann);
// assert_eq!(binary, 1);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.3 MATCH ENUM WITH ENUM INPUT
//**************************************************************************************************
// let msgs = [
//     Message03::Quit,
//     Message03::Move{x:1, y:3},
//     Message03::ChangeColor(255,255,0)
// ];
// for msg in msgs {
//     show_message03(msg)
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.4 MATCHES, MATCH MULTIPLE VALUES, MATCH 'A','B',...,'Z'
//**************************************************************************************************
// let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];
// for ab in alphabets {
//     // https://doc.rust-lang.org/stable/core/macro.matches.html
//     // println!("{}",matches!(ab, 'A'..='Z' | 'a'..='z'))
//     // a => true
//     // E => true
//     // 0 => false
//     // 9 => false
//     assert!(matches!(ab, 'A'..='Z' | 'a'..='z'|'0'..='9'));
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.5 ENUM CONDITION
//**************************************************************************************************
// let mut count = 0;
// let v = vec![MyEnum05::Foo,MyEnum05::Bar,MyEnum05::Foo];
// for e in v {
//     match e { // Fix the error by changing only this line
//         MyEnum05::Foo=>count += 1,
//         _=>(),
//     }
// }
// assert_eq!(count, 2);
// println!("Success!");

// //**************************************************************************************************
// // EXAMPLE NO.6 IF LET SOME
// //**************************************************************************************************
// let o = Some(7);
// // Remove the whole `match` block, using `if let` instead 
// if let Some(i) =o{
//     println!("This is a really long string and `{:?}`", i);
//     println!("Success!");
// };

//**************************************************************************************************
// EXAMPLE NO.7 IF LET ENUM
//**************************************************************************************************
// let a = Foo07::Bar(1);
// if let Foo07::Bar(i)=a{
//     println!("foobar holds the value: {}", i);
//     println!("Success!");
// }

//**************************************************************************************************
// EXAMPLE NO.8 USING MATCH RETURN MULTIPLE LINES FUNCTION
//**************************************************************************************************
// let a = Foo08::Qux(10);
// // Remove the codes below, using `match` instead 
// match a{
//     Foo08::Bar=>{
//         println!("The first options");
//         println!("match foo::bar")},
//     Foo08::Baz=>println!("match foo::baz"),
//     _=>println!("match others")
// }
// let a = Foo08::Bar;
// // Remove the codes below, using `match` instead 
// match a{
//     Foo08::Bar=>{
//         println!("The first options");
//         println!("match foo::bar")},
//     Foo08::Baz=>println!("match foo::baz"),
//     _=>println!("match others")
// }

//**************************************************************************************************
// EXAMPLE NO.9 IF LET DE-SOME
//**************************************************************************************************
// let age = Some(30);
// if let Some(age) = age {
//     // The age in this scope is automatically copied.
//    assert_eq!(age, 30);
// } // The cloned age variable goes out of scope here
// match age {
//     // The true age variable is not dropped.
//     Some(age) =>  println!("age is a new variable, it's value is {}",age),
//     _ => ()
// }
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************

 
 // Create a new variable with the same name as previous `age`
 
// MY VER
// let age = Some(30);
// let age = if let Some(age) = age {
//    assert_eq!(age, 30);
//    Some(age)
// }else{
//     None
// }; 
// match age {
//     Some(age) =>  println!("age is a new variable, it's value is {}",age),
//     None => ()
// }

// TEACHER'S VER
 
    // Match can also introduce a new shadowed variable
 
// Create a new variable with the same name as previous `age
 
// The new variable `age` goes out of scope here
 
   return age
 
if 
 
if let Foo08::Bar = a {
    println!("match foo::bar")
} else if let Foo08::Baz = a {
    println!("match foo::baz")
} else {
    println!("match others")
}

 
    }
 
    Some(i) => {
 
    _ => {}
 
MyEnum05::Foo
 

    // Fill the blank with `matches!` to make the code work
 
:Message:
 
//assert_eq!(binary, 1);
// println!("{}",binary);

 

// Fill the blank with a match expression:
//
// boolean = true => binary = 1
// boolean = false =>  binary = 0
 


let boolean = true;
 
match booleann{
    true=>println!("Honest"),
    _=>println!("Lier"),
};
 
println!("Success!");
 
let binary = match 
 
boolean==
 
    // Fill the blank with a match expression:
    //
    // boolean = true => binary = 1
    // boolean = false =>  binary = 0
 
    _ => (),
 
Direction01::
 
    _ => (),
 
//
 
    Direction01::West => println!("East"),
    Direction01::North=> println!("East"),
    Direction01::South=> println!("East"),
 
    None => (),
 

fn main() {
//**************************************************************************************************
// EXAMPLE NO.1 IF/ELSE
//**************************************************************************************************
// let n = 5;
// 
// if n < 0 {
//     println!("{} is negative", n);
// } else if n > 0 {
//     println!("{} is positive", n);
// } else {
//     println!("{} is zero", n);
// }

//**************************************************************************************************
// EXAMPLE NO.2 USE CONDITION IN VARIABLE INITIALIZATION
//**************************************************************************************************
// let n = 5;
// let big_n:f64 =if n < 10 && n > -10 {
//     println!(", and is a small number, increase ten-fold");
//     10.0 * (n as f64)
// } else {
//     println!(", and is a big number, halve the number");
//     (n as f64)/ 2.0 
// };
// println!("{} -> {}", n, big_n);

//**************************************************************************************************
// EXAMPLE NO.2.2 YOU CAN CEIL THE FRACTIONAL NUMBER AS I32
//**************************************************************************************************
// let n:i32=55;
// let m:i32=n/2.0 as i32;
// println!("{} / 2 = {}",n,m);
// let n:i32=56;
// let m:i32=n/2.0 as i32;
// println!("{} / 2 = {}",n,m);

//**************************************************************************************************
// EXAMPLE NO.3 FOR 1 TO 99
//**************************************************************************************************
// // Loop 1 to 99
// for n in 1..=99 { 
//     if n == 100 {
//         panic!("NEVER LET THIS RUN");
//         // panic is not executed.
//     }
// }
// println!("Success!");
// // Loop 1 to 99
// for n in 1..100 { 
//     println!("{}",n);
//     if n == 100 {
//         panic!("NEVER LET THIS RUN");
//         // panic is not executed.
//     }
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.4 REFERENCE AND CLONE ARRAY BEFORE LOOPING IT
//**************************************************************************************************
// let names:[String;2] = [String::from("liming"),String::from("hanmeimei")];
// // Ownership Rule
// // 1. Each value has an ower.
// // 2. There can only be one owner at a time.
// // 3. When the owner go out of scope, the value will be drop.

// // In this case, we need to & (borrowing the value of) names
// // because without &, the value of names will be used and droped in
// // this forloop, and thus cannot be used again in println!({:?},names)
// for name in &names {
//     // let name = *name // automatically
//     println!("{}",name);
// }
// println!("{:?}", names);

// let numbers:[i32;3] = [1, 2, 3];
// // In the second loop, we do not need to use & because the value of numbers
// // are copy automatically, and thus it not droped inside the for loop.
// for n in numbers {
//     println!("{}",n);
// }
// println!("{:?}", numbers);

//**************************************************************************************************
// EXAMPLE NO.5 GET INDEX FOR THE CURRENT ELEMENT IN FOR LOOP
//**************************************************************************************************
// https://stackoverflow.com/questions/66288515/how-do-i-get-the-index-of-the-current-element-in-a-for-loop-in-rust
// let a = [4, 3, 2, 1];
// // Iterate the indexing and value in 'a'
// // a is copy automatically, thus a can be used again.
// for (i,v) in a.iter().enumerate() {
//     println!("The {}th element is {}",i+1,v);
// }

//**************************************************************************************************
// EXAMPLE NO.6 WHILE LOOP
//**************************************************************************************************
// // A counter variable
// let mut n = 1;
// // Loop while the condition is true
// while n < 10 {
//     if n % 15 == 0 {
//         println!("fizzbuzz");
//     } else if n % 3 == 0 {
//         println!("fizz");
//     } else if n % 5 == 0 {
//         println!("buzz");
//     } else {
//         println!("{}", n);
//     }
//     n=n+1;
// }
// println!("n reached {}, so loop is over",n);

//**************************************************************************************************
// EXAMPLE NO.7 BREAK
//**************************************************************************************************
// let mut n = 0;
// for i in 0..=100 {
//    if n == 66 {
//        break
//        // stop the loop
//        // when n == 66
//    }
//    n += 1;
// }
// assert_eq!(n, 66);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.8 CONTINUE
//**************************************************************************************************
// let mut n = 0;
// for i in 0..=100 {
//    if n != 66 {
//        n+=1;
//        continue
//    }
//    continue
// }
// assert_eq!(n, 66);
// println!("{}",n);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.9
//**************************************************************************************************
// let mut count = 0u32;
// println!("Let's count until infinity!");
// // Infinite loop
// loop {
//     count += 1;
//     if count == 3 {
//         println!("three");
//         continue;
//     }
//     println!("{}", count);
//     if count == 5 {
//         println!("OK, that's enough");
//         break;
//     }
// }
// assert_eq!(count, 5);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.10 BREAK RETURN VALUE
//**************************************************************************************************
// let mut counter = 0;
// let result = loop {
//     counter += 1;
//     if counter == 10 {
//         counter=counter*2;
//         break counter;
//     }
// };
// assert_eq!(result, 20);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.11 BREAK NESTED LOOP
//**************************************************************************************************
// let mut count = 0;
// let mut count_out = 0;
// let mut count_in = 0;
// 'outer: loop {
//     println!("Out: {}",count_out);
//     println!("count = {}",count);
//     'inner1: loop {
//         if count >= 20 {
//             // This would break only the inner1 loop
//             break 'inner1; // `break` is also works.
//         }
//         println!("In: {}",count_in );
//         println!("count = {}",count);
//         count += 2;
//         count_in +=1;
//     }
//     count += 5;
//     'inner2: loop {
//         if count >= 30 {
//             // This breaks the outer loop
//             break 'outer;
//         }
//         // This will continue the outer loop
//         continue 'outer;
//     }
//     count_out+=1
// }
// // assert!(count == __);
// println!("{}",count);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.12
//**************************************************************************************************
// let mut n=0;
// let mut m=0;
// for i in 0..10{
//     let mut s="".to_string();
//     for j in 0..10{
//         if i%2==0{
//             println!("{}",s);
//         }
//         // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
//         // https://rustjobs.dev/blog/convert-int-to-string-in-rust/
//         s.push_str(&j.to_string());
//     }
//     if i%2==1{
//         for j in 0..10{
//             println!("{}",s);
//             // https://stackoverflow.com/questions/65976432/how-to-remove-first-and-last-character-of-a-string-in-rust
//             s.pop();
//         }
//     }
// }

/*
let mut n=0;
let mut m=0;
let mut i:u32=0;
'out:loop {
    let mut s="".to_string();
    let mut bo:u32=0;
    'in1: loop {
        if i%2==0{
            println!("{}",s);
        }
        if bo>=10{
            break 'in1;
        }
        // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
        // https://rustjobs.dev/blog/convert-int-to-string-in-rust/
        s.push_str(&bo.to_string());
        bo+=1;
    }
    let mut bo:u32=0;
    if i%2==1{
        'in2: loop{
            println!("{}",s);
            // https://stackoverflow.com/questions/65976432/how-to-remove-first-and-last-character-of-a-string-in-rust
            s.pop();
            bo+=1;
            if bo>=10{
                break 'in2;
            }
        }
    }

    i+=1;
    'in3: loop{
        if i>=10{
            break 'out;
        }
    }
}
*/
} 


 
bo+=1;
 
for j in 0..10
 
for j in 0..10
 
    println!("{}",s)
 
        let mut s:&str=&s;
 
// https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
 
println!("{}",s);
 
}
    else{
    for j in 0..10{
        println!("{}",s);
        // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
        s.push_str("*")
    }}
 
if i%2==0{
 
let mut s="".to_string();
 
println!("{}",s);
    s.push_str("*")
 
let mut s="".to_string();
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************

 
 // `break` is also works.
 
            // This would break only the inner1 loop
 
            // This breaks the outer loop
 
        // This will continue the outer loop
 
            // This would break only the inner1 loop
 
counter
 
        counter*2
 
       __;
 
.clone()
 
ref
 
// The elements in numbers are Copyso there is no move here
 
// 
 
i32
 
String
 
// 
 
    // Do something with name...
 
let n:i32=55;
let m:i32=n/2.0 as i32;
println!("{} / 2 = {}",n,m);
let n:i32=56;
let m:i32=n/2.0 as i32;
println!("{} / 2 = {}",n,m);
 
    println!("{}",n);
 

fn main() {
// Fill in the blanks
 
// modify this line to make the code work
 
use crate::List::*;
// https://doc.rust-lang.org/book/ch15-01-box.html
enum List {
    Cons(char, Box<List>),
    Nil,
}

impl List {
    fn new() -> List {
        Nil
        // https://doc.rust-lang.org/book/ch15-01-box.html
        // Cons('A',Box::new(Nil))
        // 'A' is the first string.
    }

    fn prepend(self, elem: char) -> List {
        // List = Type of the output
        Cons(elem, Box::new(self))
    }

    // len = length
    fn len(&self) -> u32 { 
        // https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html
        match *self {
            Cons(ii, ref tail) => 1 + tail.len(),
            Nil => 0
        }
    }

    fn stringify(&self) -> String {
        match *self {
            Cons(head,  ref tail) => {
                // ref tail = get the reference of tail
                format!("{}{}", tail.stringify(),head)
            },
            Nil => {
                format!("")
            },
        }
    }

    fn index(&self,max:u32)->char{
        // Helped by ChatGPT
        fn counting(node: &List, count: u32, max: u32) -> Option<char> {
            match node {
                Cons(head, tail) => {
                    if count == max {
                        Some(*head)
                    } else {
                        counting(tail, count + 1, max)
                    }
                },
                Nil => None,
            }
        }
        let count:u32=0;
        let output:Option<char>=counting(self,count,max);
        match output{
            Some(c)=>{
                c
            }
            None=>{
                println!("The Input is invalid");
                ' '
            }
        }
    }

}
 
    // Create an empty linked list
    let mut list = List::new();

    // Prepend some elements
    list = list.prepend('H');
    list = list.prepend('e');
    list = list.prepend('l');
    list = list.prepend('l');
    list = list.prepend('o');
    list = list.prepend(' ');
    list = list.prepend('W');
    list = list.prepend('o');
    list = list.prepend('r');
    list = list.prepend('l');
    list = list.prepend('d');

    // Show the final state of the list
    //println!("linked list has length: {}", list.len());
    println!("{}", list.stringify());
    let mut i=0;
    println!("For Loop");
    while i<list.len(){
        println!("list[{}] = {}",i, list.index(i));
        i=i+1
    }
 
    // Return the length of the list
 
    // Return the length of the list
 
    // Return representation of the list as a (heap allocated) string
 
 console
 
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the
 
println!("list[0] = {}", list.index(0));
 
ref 
 
ref 
 
        /*
no method named `counting` found for reference `&List` in the current scope
method not found in `&List`
        */
 
tail.
 
self.
 
                    count=count+1;
 
 mut
 
                
 
            }
 
    */
 


    /*
 
    fn index(&self,index:u32)->char{
        let mut count:u32=0;
        match *self{
            Cons(ii, ref tail) => {
                if index==count{
                    ii
                }else{
                    count=count+1;
                    tail.index(index,count);
                }
            },
            // 1 + tail.len()
            Nil => ' '
        }
    }
 
tail.index()
 
    fn index()
 
let mut count:u32=0;
 
List::
 
ref 
 
                // format!("{}{}", tail.count(),head)
 
output
 
        let output:char=' ';
 
mut 
 
output=
 
Option<
 
count
 
,c:u32
 
c=
 
ing
 
            //
        }
 
println!(\"
 
stringify()
 
tail.stringify()
 
")"
 
{
            
 
    fn stringify(&self)->String{
        self.stringifys()+")"
    }
 
println!(
 
.to_string()
 
        if self.len==1{
            self.prepend(')')
        }
 
head
 
    list = list.prepend('o');
 
.to_string()
 
Cons
 
Cons
 
.Cons
 
.to_string()
 
            // Base Case: An empty list has zero length
 
            // Can't take ownership of the tail, because `self` is borrowed;
            // Instead take a reference to the tail
 
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&T`
        // After Rust 2018 you can use self here and tail (with no ref) below as well,
        // rust will infer &s and ref tail.
 

    // Return the length of the list
 
        // `Cons` also has type List
 

    // Consume a list, and return the same list with a new element at its front
 
u32,Box<List>
 
        // `Nil` has type `List`
 
    // Create an empty list
 

// Methods can be attached to an enum
 
    // Cons: Tuple struct that wraps an element and a pointer to the next node
 
    // Nil: A node that signifies the end of the linked list
 
 -> (u32,Box<List>)
 
Cons
 
Cons
 
    let msgs: [Message;3] = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
 
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl fmt::Display for Message{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Message::Quit => write!(f, "Quit"),
            Message::Move{x, y} => write!(f, "Move: ({}, {})",x,y),
            Message::Write(text) => write!(f, "Write: {}",text),
            Message::ChangeColor(r,g,b) => write!(f, "ChangeColor: ({:?})",(r,g,b)),
        }
    }
}
fn show_message(msg: Message) {
    println!("{}", msg);
    //dbg!(msg);
}

 
rgb
 
// 
 
println!("\n//**************************************************************************************************");
println!("// INITIALIZE TWOWUV");
println!("//**************************************************************************************************");
let mut island_in_the_sun:TwoWuv=TwoWuv{
    x:(2.0_f64).powf(0.5_f64),
    y:0.0
};
// https://doc.rust-lang.org/rust-by-example/hello/print/print_debug.html
// println!("{:?}",island_in_the_sun); // invalid
let hawaii_part_ii:TwoWuv=TwoWuv{
    x:5.1413,
    y:2.8172
};
// https://prince.dev/debug-struct
// dbg!(hawaii_part_ii.x); // valid
// dbg!(hawaii_part_ii); // invalid
dbg!(island_in_the_sun.x);
dbg!(island_in_the_sun.y);
dbg!(hawaii_part_ii.x);
dbg!(hawaii_part_ii.y);

println!("\n//**************************************************************************************************");
println!("// PLUS, MINUS, TIMES, DEVIDE, POWER, LOG");
println!("//**************************************************************************************************");
println!("{} + {} = {}",hawaii_part_ii.x,hawaii_part_ii.y,hawaii_part_ii.plus());
println!("{} - {} = {}",hawaii_part_ii.x,hawaii_part_ii.y,hawaii_part_ii.minus());
println!("{} * {} = {}",hawaii_part_ii.x,hawaii_part_ii.y,hawaii_part_ii.times());
println!("{} / {} = {}",hawaii_part_ii.x,hawaii_part_ii.y,hawaii_part_ii.divide());
println!("{} ^ {} = {}",hawaii_part_ii.x,hawaii_part_ii.y,hawaii_part_ii.power());
println!("log _{} ({}) = {}",hawaii_part_ii.y,hawaii_part_ii.x,hawaii_part_ii.logarithm());

println!("\n//**************************************************************************************************");
println!("// FUNCTION");
println!("//**************************************************************************************************");

hawaii_part_ii.help();
println!("sin({}) = {}",hawaii_part_ii.x,hawaii_part_ii.function(Some('x'),Some('s')));
println!("sin({}) = {}",hawaii_part_ii.y,hawaii_part_ii.function(Some('y'),Some('s')));
println!("log({}) = {}",hawaii_part_ii.y,hawaii_part_ii.function(Some('y'),Some('l')));
println!("cos({}) = {}",hawaii_part_ii.x,hawaii_part_ii.function(Some('x'),Some('c')));
println!("tan({}) = {}",hawaii_part_ii.x,hawaii_part_ii.function(Some('x'),Some('t')));

println!("\n//**************************************************************************************************");
println!("// ERROR");
println!("//**************************************************************************************************");
println!("{} / {} = {}",island_in_the_sun.x,island_in_the_sun.y,island_in_the_sun.divide());
println!("log({}) = {}",island_in_the_sun.y,island_in_the_sun.function(Some('y'),Some('l')));
println!("log _{} ({}) = {}",island_in_the_sun.y,island_in_the_sun.x,hawaii_part_ii.logarithm());

println!("\n//**************************************************************************************************");
println!("// UPDATE");
println!("//**************************************************************************************************");
island_in_the_sun.y=(3.0_f64).powf(0.5_f64);
println!("{} / {} = {}",island_in_the_sun.x,island_in_the_sun.y,island_in_the_sun.divide());

 

// https://doc.rust-lang.org/std/f64/consts/constant.E.html
pub const E: f64 = 2.71828182845904523536028747135266250_f64; // 2.7182818284590451f64
// https://doc.rust-lang.org/std/f64/consts/constant.PI.html
pub const PI: f64 = 3.14159265358979323846264338327950288_f64; 

struct TwoWuv{
    x:f64,
    y:f64
}

impl TwoWuv{

    fn plus(&self)->f64{
        self.x+self.y
    }
    fn minus(&self)->f64{
        self.x-self.y
    }
    fn times(&self)->f64{
        self.x*self.y
    }
    fn divide(&self)->f64{
        if self.y==0.0{
            println!("The Input is invalid");
            0.0
        } else{
            self.x/self.y
        }
    }
    fn power(&self)->f64{
        // https://stackoverflow.com/questions/51208703/how-to-raise-a-number-to-a-power
        f64::powf(self.x,self.y)
    }

    fn logarithm(&self)->f64{
        if(self.y!=1.0 && self.y>0.0_f64 && self.x>0.0_f64){
            self.x.log(self.y)
        } else{
            println!("Input is in valid");
            0.0
        }
    }

    fn help(&self)->(){
        println!("function");
        println!("Input var");
        println!("1. x == x");
        println!("2. y == x");
        println!("3. Default == x");
        println!("Input fun");
        println!("1. x == x");
        println!("2. s == sin(x)");
        println!("3. c == cos(x)");
        println!("4. t == tan(x)");
        println!("5. e == e^x");
        println!("6. l == ln(x)");
        println!("7. a == |a|");
        println!("8. Default == x");
    }

    fn function(
        &self,
        var:Option<char>,
        // x == x
        // y == y
        // default == x
        fun:Option<char>
        // x == x
        // s == sin(x)
        // c == cos(x)
        // t == tan(x)
        // e == e^x
        // l == ln(x)
        // a = |x|
        // default == x
    )->f64{
        let mut z:f64=0.0;
        let mut output:Option<f64>=None;
        match var{
            Some(vvv)=>{
                if vvv=='y'{
                    z=self.y;
                } else {
                    z=self.x;
                }
            }
            None=>{z=self.x}
        }
        match fun{
            Some(fff)=>{
                if(fff=='x'){output=Some(z)}
                else if(fff=='s'){output=Some(z.sin())}
                else if(fff=='c'){output=Some(z.cos())}
                else if(fff=='t'){
                    // https://stackoverflow.com/questions/62144550/how-to-round-a-number-up-or-down-in-rust
                    let floor:i32=((2.0*(z as f64)/PI-1.0)/2.0).floor() as i32;
                    let ceil:i32=((2.0*(z as f64)/PI-1.0)/2.0).ceil() as i32;
                    if((PI/2.0-0.00001)*((2*floor+1) as f64)<z&&z<(PI/2.0+0.00001)*((2*floor+1) as f64)){output=None}
                    else if((PI/2.0-0.00001)*((2*ceil+1) as f64)<z&&z<(PI/2.0+0.00001)*((2*ceil+1) as f64)){output=None}
                    else{output=Some(z.tan())}
                }
                else if(fff=='e'){output=Some(f64::powf(E,z))}
                else if(fff=='l'){
                    if z <= 0.0_f64 {
                        output = None
                    } else {
                        output = Some(z.log(E))
                    }
                }
                else if(fff=='a'){output=Some(z.abs())}
                else{output=Some(z)}
            }
            None=>{output=Some(z)}
        }
        match output{
            Some(yyy)=>{yyy}
            None=>{
                println!("The Input is invalid");
                0.0
            }
        }
    }
}

/*
Reference
1. https://doc.rust-lang.org/std/keyword.impl.html
2. https://doc.rust-lang.org/rust-by-example/flow_control/if_else.html
3. https://doc.rust-lang.org/std/option/
4. https://stackoverflow.com/questions/51208703/how-to-raise-a-number-to-a-power
*/

 
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    // https://prince.dev/debug-struct
    f.debug_struct("TwoWuv")
      .field("x", &self.x)
      .field("y", &self.y)
      .finish()
    }
 

impl fmt::Debug for TwoWuv{
    fn 
}
 
// https://prince.dev/debug-struct
// https://youtu.be/BpPEoZW5IiY?si=goDW5z6qEkPok4pe
 
// 
 
// `TwoWuv` doesn't implement `Debug`
// the trait `Debug` is not implemented for `TwoWuv`
 
// 
 
.to_string()
 
// #[derive(Debug)] // used for debugging
 
// 
 
Option<
 
Option<
 
fun=
 
var=
 
{} + {} = {}
 
var
 

//**************************************************************************************************
// HELP
//**************************************************************************************************
hawaii_part_ii.help();

 
let mut island_in_the_sun:TwoWuv=TwoWuv{
    x:3.1415,
    y:0.0
};
 
Some
 
Option
 
let irrational
 

    fn 
 
output=Some(
 
        let mut output:Option<f64>=None;
 
 as f64
 
ln(x)
 
Option<
 
                
 
                    
 
                    if z <= 0.0_f64 {
                        output = None;
                    } else {
                        output = Some(z);
                    }
 
9323846264338327950288_f64
 
let mut ztan:i32=0;
 
*ztan
 
z==
 
                        
 
                    
 
                        
 
.cos()
 
Option<f64>
 
        fn select(&self,x:u8)->f64{
            if(x==1){self.y}
            else{self.x}
        }
 
            Some(1)=>
 
ction
 
iable
 
iable
 
_mode
 

enum TwoWuv{
    X,
    Y
}
 

struct Diculator{
    num1:i32,
    num2:i32,
}
 
9. y=x,x=y
 
//**************************************************************************************************

enum Number {
    Zero,
    One,
    Two,
}
enum Number1 {
    Zero = 0,
    One,
    Two,
}
enum Number2 {
    // You cannot use f32 and f64 in Enum
    Zero = 0,
    One = 1,
    Two = 2,
}


//**************************************************************************************************
// PRINTLN ENUM
//**************************************************************************************************

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor((i32, i32, i32)),
}
impl fmt::Display for Message{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Message::Quit => write!(f, "Quit"),
            Message::Move{x, y} => write!(f, "Move: ({}, {})",x,y),
            Message::Write(text) => write!(f, "Write: {}",text),
            Message::ChangeColor(rgb) => write!(f, "ChangeColor: ({:?})",rgb),
        }
    }
}

enum Suit {
    Heart,
    Diamond,
    Spade,
    Club
}
impl fmt::Display for Suit {
    // https://stackoverflow.com/questions/28024373/is-there-a-way-to-print-enum-values
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
       match self {
           Suit::Heart => write!(f, ""),
           Suit::Diamond => write!(f, ""),
           Suit::Spade => write!(f, ""),
           Suit::Club => write!(f, ""),
       }
    }
}

//**************************************************************************************************

fn show_message(msg: Message) {
    println!("{}", msg);
}
/*
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        __ => None,
        __ => Some(i + 1),
    }
}
*/
fn absolutenaturalnumber(x:i32)->Option<u16>{
    if x==0{
        None
    } else{
        if x>0{
            Some(x as u16)
        }
        else{
            Some((-1*x) as u16)
        }
    }
}

fn matrixproduct_dim(a:(i32,i32),b:(i32,i32))->Option<(i32,i32)>{
    if a.1==b.0{
        Some((a.0,b.1))
    } else{
        None
    }
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
 
/**************************************************************************************************
// EXAMPLE NO.1 INITIALIZE ENUM
//**************************************************************************************************
// assert_eq!(Number::One as i32, Number1::One as i32);
// assert_eq!(Number1::One as i32, Number2::One as i32);

//**************************************************************************************************
// EXAMPLE NO.2 EACH ENUM CAN HOLD ITS OWN DATA.
//**************************************************************************************************
// let msg1:Message = Message::Move{x:1_i32,y:2_i32}; // Instantiating with x = 1, y = 2 
// let msg2:Message = Message::Write("hello, world!".to_string()); // Instantiating with "hello, world!"

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
//let msg = Message::Move{x: 1, y: 1};
// if let Message::Move{x:a,y:b} = msg {
//     assert_eq!(a, b);
// } else {
//     panic!("NEVER LET THIS RUN");
// }
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.4 PRINTLN ENUM
//**************************************************************************************************
// https://stackoverflow.com/questions/28024373/is-there-a-way-to-print-enum-values
// let s = Suit::Heart;
// println!("s = {}", s);
// let msg = Message::Move{x: 1, y: 1};
// println!("msg = {}",msg);
// let msg = Message::Quit;
// println!("msg = {}",msg);
// let msg = Message::Write("Hello World".to_string());
// println!("msg = {}",msg);
// let msg = Message::ChangeColor { rgb: (255,0,0) };
// println!("msg = {}",msg);
// // s = 
// // msg = Move: (1, 1)
// // msg = Quit
// // msg = Write: Hello World
// // msg = ChangeColor: ((255, 0, 0))

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
// let msgs:[Message;3] = [
//     Message::Quit,
//     Message::Move{x:1, y:3},
//     Message::ChangeColor((255,255,0))
// ];
// for msg in msgs {
//         show_message(msg)
// }

//**************************************************************************************************
// EXAMPLE NO.6 SOME AND NONE
//**************************************************************************************************
// // https://doc.rust-lang.org/std/option/
// let lists:[i32;3] = [0,1,-1];
// for i in lists{
//     match absolutenaturalnumber(i){
//         Some(i) => println!("i = {i}"),
//         None => println!("Zero is not a natural number"),
//     }
// }

//**************************************************************************************************
// EXAMPLE NO.7 SOME AND NONE, DIMENSION OF MATRIX PRODUCT
//**************************************************************************************************
// let matrixpair_dim:[[(i32,i32);2];6]=[
//     [(2,3),(3,4)],
//     [(5,5),(3,4)],
//     [(2,5),(5,4)],
//     [(1,3),(3,1)],
//     [(2,3),(1,4)],
//     [(2,2),(1,4)],
//     ];
// for i in matrixpair_dim{
//     let a:(i32,i32) = i[0];
//     let b:(i32,i32) = i[1];
//     let c:Option<(i32,i32)> = matrixproduct_dim(a,b);
//     match c{
//         Some(c) =>println!("{:?} * {:?} = {:?}",a,b,c),
//         None=>println!("The product of {:?} and {:?} is invalid",a,b)
//     }
// };

//**************************************************************************************************
// EXAMPLE NO.8
//**************************************************************************************************
// let five = Some(5);
// let six = plus_one(five);
// let none = plus_one(None);
// if let Some(n) = six {
//     // if six != None
//     println!("{}", n);
//     println!("Success!");
// } 
// else{
//     // if six == None
// panic!("NEVER LET THIS RUN");
// }
 
//**************************************************************************************************
// EXAMPLE NO.9 IMPL MATRIX
//**************************************************************************************************
let mut a = Matrix::new(5,7);
let b = Matrix{
    row:5,
    col:7
};
a.print_shape();
b.print_shape();
a.check_equality(b);
a=a.transpose();
a.print_shape();
a.check_equality(b);
 
//**************************************************************************************************
// IMPL
//**************************************************************************************************
// https://www.youtube.com/watch?v=LKYSl7kM5q8
/* 
Question: When to use self, &self, &mut self in methods?
Answer:
&self
 * Read the static data without modify it. (we dont want to take ownership)
&mut self
 * If we wanted to change the instance that weve called the method on as part of what the method does, wed use &mut self as the first parameter.
self
 * Rarely use.
Reference: https://stackoverflow.com/questions/59018413/when-to-use-self-self-mut-self-in-methods
*/
/*
Question: The different between self and Self?
Answer:
Self (uppercase)
 * The type of the struct which is also the input of the method.
self 
 * The instance of the selected object.
Reference: https://www.reddit.com/r/rust/comments/obs9qd/what_is_self_in_rust/
*/
struct Matrix{
    row:u32,
    col:u32
}

impl Matrix{
    fn new(row:u32,col:u32)->Self{
        Matrix{row:row,col:col}
    }
    fn print_shape(self){
        let data=&self;
        println!("[{} x {}]",data.row,data.col);
    }
    fn product_dim(&self,&b:Self)->Self{
        //let b = &b;
        if self.col == b.row{
        Matrix{row:self.row,col:b.col}
        } else{
            //self.print_shape();
            //b.print_shape();
            println!("[{} x {}]",b.row,b.col);
            println!("The product of both matrix is invalid.");
            Matrix{row:self.row,col:self.col}
        }
    }
    fn check_equality(&self,b:Self){
        let b =&b;
        if self.row==b.row && self.col==b.col{
            println!("The 2 matrix have same dimensions");
        }else{
            println!("The 2 matrix have different dimensions");
        }
    }
    fn transpose(&self)->Self{
        Matrix{row:self.col,col:self.row}
    }
    // fn add_row
    // fn sub_row
    // fn add_col
    // fn sub_col
    // fn determinant
}

 
//**************************************************************************************************
// IMPL
//**************************************************************************************************
// https://www.youtube.com/watch?v=LKYSl7kM5q8
/* 
Question: When to use self, &self, &mut self in methods?
Answer:
&self
 * Read the static data without modify it. (we dont want to take ownership)
&mut self
 * If we wanted to change the instance that weve called the method on as part of what the method does, wed use &mut self as the first parameter.
self
 * Rarely use.
Reference: https://stackoverflow.com/questions/59018413/when-to-use-self-self-mut-self-in-methods
*/
/*
Question: The different between self and Self?
Answer:
Self (uppercase)
 * The type of the struct which is also the input of the method.
self 
 * The instance of the selected object.
Reference: https://www.reddit.com/r/rust/comments/obs9qd/what_is_self_in_rust/
*/
struct Matrix{
    row:u32,
    col:u32
}

impl Matrix{
    fn new(row:u32,col:u32)->Self{
        Matrix{row:row,col:col}
    }
    fn print_shape(self){
        let data=&self;
        println!("[{} x {}]",data.row,data.col);
    }
    fn product_dim(&self,&b:Self)->Self{
        //let b = &b;
        if self.col == b.row{
        Matrix{row:self.row,col:b.col}
        } else{
            //self.print_shape();
            //b.print_shape();
            println!("[{} x {}]",b.row,b.col);
            println!("The product of both matrix is invalid.");
            Matrix{row:self.row,col:self.col}
        }
    }
    fn check_equality(&self,b:Self){
        let b =&b;
        if self.row==b.row && self.col==b.col{
            println!("The 2 matrix have same dimensions");
        }else{
            println!("The 2 matrix have different dimensions");
        }
    }
    fn transpose(&self)->Self{
        Matrix{row:self.col,col:self.row}
    }
    // fn add_row
    // fn sub_row
    // fn add_col
    // fn sub_col
    // fn determinant
}

 
        let data=&self
 
        let b2=b;
 
a.check_equality(b);
 
    // If the mut keyword is used with the & symbol, we can modify a borrowed value:
 
/*
What is Ownership?
 * Each value in Rust have only one owner (variable) at the time.
 * 
Reference: https://www.educative.io/answers/how-to-use-references-in-rust
*/
 

{
    let pi = 22/7
}
 
pi is the owner and 3.14 is the value
 
let e:f64=2.7;
 
The constant variable
 
 * Owner is the variable in Rust, that have the value.
 
struct LinkedFib{
    x:u32,
    y:u32
}

struct LinkedFibArray{

}

impl LinkedFib{
    // https://doc.rust-lang.org/book/ch05-01-defining-structs.html
    // https://youtu.be/Nuba5LNy5cY?si=y29SjSBAJ6yGGels
    fn start_fib()->[LinkedFib;1]{
        let first_element:LinkedFib=LinkedFib{x:0,y:1};
        [first_element]
    }
    fn push_fib([LinkedFib;num as u32]){}

}
 
    //fn add_obs(&mut self)->[LinkedFib;]{}
    fn read_len(&self)->u32{
        self.len() as u32
    }
 

struct LinkedFib{
    Vec<LinkFib
}
 
/* 

*/
 
{x:0,y:1}
 
let mut list = List::new();
list = list.prepend(1);
list = list.prepend(2);
list = list.prepend(3);
println!("linked list has length: {}", list.len());
println!("{}", list.stringify());
 
use crate::List::*;

enum List {
    Cons(u32, Box<List>),
    Nil,
}

impl List {
    fn new() -> List {
        Nil
    }

    fn prepend(self, elem: u32) -> crate::List {
        Cons(elem, Box::new(self))
    }

    fn len(&self) -> u32 {
        match *self {
            Cons(_, ref tail) => 1 + tail.len(),
            Nil => 0
        }
    }

    fn stringify(&self) -> String {
        match *self {
            Cons(head,__ tail) => {
                format!("{}, {}", head, tail.__())
            },
            Nil => {
                format!("Nil")
            },
        }
    }
}
*/
 

    // Prepend some elements
 

    // Show the final state of the list
 
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
 
    // Return representation of the list as a (heap allocated) string
 
            // Base Case: An empty list has zero length
 
            // Can't take ownership of the tail, because `self` is borrowed;
            // Instead take a reference to the tail
 
rg/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html
 
        // See https://doc.rust-lang.o
 
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&T`
        // After Rust 2018 you can use self here and tail (with no ref) below as well,
        // rust will infer &s and ref tail. 
 

    // Return the length of the list
 
(u32,Box<List>)
 
    // Consume a list, and return the same list with a new element at its front
 
        // `Cons` also has type List
 
    // Cons: Tuple struct that wraps an element and a pointer to the next node
 
    // Nil: A node that signifies the end of the linked list
 
        // `Nil` has type `List`
 
    // Create an empty list
 

// impl = 
 
*/
 
let mut list = List::new();
list = list.prepend(1);
list = list.prepend(2);
list = list.prepend(3);
println!("linked list has length: {}", list.len());
println!("{}", list.stringify());
 
// Show the final state of the list
 
// Prepend some elements
 
[(i32,i32);2]
 
let negative = 
 
let possitive = 
 
println!("{}",);
 
 as u16 * 
 

// let six = plus_one(five);
// let none = plus_one(None);
// if let __ = six {
//     println!("{}", n);
//     println!("Success!");
// } 
//     
// panic!("NEVER LET THIS RUN");
 
// 04:02:52 Enums
 
{rgb:
 
// let mut msg = Message::Move{x: 1, y: 1};
// msg = Message::Write("Hello".to_string());
// msg = Message::ChangeColor(255,0,0);
// println!("{:?}",msg);
 
Move{x: 1, y: 1}
 
{},{},{}
 
ui
 
o point
 
println!("{:?}", msg);
 
    let Message::Move { a, b}=msg;
 
Message::Move{a,b}
 
// C-like enum
 
STRUCTS
 
// let age = 30;
// let p = Person {
//     name: String::from("sunface"),
//     age,
//     hobby:"Convert &str to String.".to_string()
// };

//**************************************************************************************************
// EXAMPLE NO.2 FUNCTION WITH EMPTY STRUCT AS INPUT
//**************************************************************************************************
// let u = Unit;
// do_something_with_unit(u);

//**************************************************************************************************
// EXAMPLE NO.3 PASSING TUPLE STRUCT AS THE INPUT
//**************************************************************************************************
// let v = Color(0, 127, 255);
// check_color(v);

//**************************************************************************************************
// EXAMPLE NO.4 MUT STRUCT
//**************************************************************************************************
// let age = 18;
// let mut p = Person {
//     name: String::from("sunface"),
//     age,
//     hobby:"Eating chess".to_string()
// };
// p.age = 30;
// p.name = String::from("sunfei");

//**************************************************************************************************
// EXAMPLE NO.5 CLONE THE STRUCT AND OVER WRITE IT.
//**************************************************************************************************
// let u1 = User {
//     email: String::from("someone@example.com"),
//     username: String::from("sunface"),
//     active: true,
//     sign_in_count: 1,
// };
// let u2 = set_email(u1);

//**************************************************************************************************
// EXAMPLE NO.6 OPEN DEBUG MODE
//**************************************************************************************************
// let scale = 2;
// let rect1 = Rectangle {
//     width: 30 * scale, // Print debug info to stderr and assign the value of  `30 * scale` to `width`
//     height: 50,
// };
// //dbg!(&rect1); // Valid, Print debug info to stderr
// // [src/main.rs:112] &rect1 = Rectangle {
// //     width: 60,
// //     height: 50,
// // }
// //println!("{}",rec1); // Invalid
// println!("{:?}",rect1); // Valid
// // Rectangle { width: 60, height: 50 }
// let num=88;
// dbg!(num);
// // [src/main.rs:121] num = 88
// println!("{:?}",num);
// // 88

//**************************************************************************************************
// EXAMPLE NO.7 PARTIAL MOVE, THERE IS NO ERROR HERE, BUT IN THE WEBSITE.
//**************************************************************************************************
// let person = Person2B {
//     name: String::from("Alice"),
//     age: Box::new(20),
// };
// // `name` is moved out of person, but `age` is referenced
// let Person2B { name, ref age } = person;
// println!("The person's age is {}", age);
// println!("The person's name is {}", name);
// // Error! borrow of partially moved value: `person` partial move occurs
// //println!("The person struct is {:?}", person);
// // `person` cannot be used but `person.age` can be used as it is not moved
// println!("The person's age from person struct is {}", person.age);

//**************************************************************************************************
// EXAMPLE NO.8
//**************************************************************************************************
// let f = File {
//     name: String::from("readme.md"),
//     data: "Rust By Practice".to_string()
// };
// let _name = f.name;
// // ONLY modify this line
// println!("{}, {}",_name, f.data);
 
struct Rectangle {
    width: u32,
    height: u32,
}
struct Person {
    name: String,
    age: u8,
    hobby: String
}
struct Person2 {
    name: String,
    age: u8,
}

struct Person2B {
    name: String,
    age: Box<u8>,
}
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

struct File {
    name: String,
    data: String,
}

fn set_email(u: User) -> User {
    User {
        email: String::from("contact@im.dev"),
        ..u
    }
}
fn build_person(name: String, age: u8) -> Person2 {
    Person2 {
        age,
        name
    }
}
struct Unit;
trait SomeTrait {
    // ...Some behaviors defined here.
}

// We don't care about what fields  are  in the Unit, but we care about its behaviors.
// So we use a struct with no fields and implement some behaviors for it
impl SomeTrait for Unit {  }
fn do_something_with_unit(u: Unit) {   }


struct Color(i32, i32, i32);

fn check_color(p: Color) {
    //let (x, y, z) = p; // invalid
    let Color(x, _, z) = p; // invalid
    // let x= p.0; valid
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(p.2, 255);
 }
 
 {:?}
 
// ONLY modify this line
 
// [src/main.rs:112] &rect1 = Rectangle {
//     width: 60,
//     height: 50,
// }
 

    // How can you believe sunface is only 18? 
 

    // Fill the blank
 
Color
 
    let x= p.0;
 
/* */
 
    project_name: "JOCR",
 
// let _t0: (u8,i16) = (0, -1);
// // Tuples can be tuple's members
// let _t1: (u8, (i16, u32)) = (0, (-1, 1));
// // Fill the blanks to make the code work
// let t: (u8, u16, i64, &str, String) = (1u8, 2u16, 3i64, "hello", String::from(", world"));

//**************************************************************************************************
// EXAMPLE NO.2 INDEXING
//**************************************************************************************************
// let t = ("i", "am", "sunface");
// assert_eq!(t.2, "sunface");
// // println!("{}",t[0]); // invalid
// println!("{}",t.0); // valid
// println!("{}",t.1); // valid
// println!("{}",t.2); // valid

//**************************************************************************************************
// EXAMPLE NO.3 MAX LENGTH = 12
//**************************************************************************************************
// // https://www.reddit.com/r/rust/comments/11gvkda/why_rust_std_only_provides_trait_implementation/
// // Rust currently doesnt have a general way to write a single trait implementation for tuples of any length. So instead you have to pick an arbitrary maximum length, and use a macro (or hand-written implementations) to implement your trait for every tuple type up to that length.
// // I believe 12 is just the arbitrary maximum that the Rust maintainers picked. Its more than large enough for the overwhelming majority of tuples that will ever be encountered in real code.
// //let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
// let too_long_tuple = (1, 2, 3,4,5,6,7,8,9,10,11,12);
// println!("too long tuple: {:?}", too_long_tuple);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
// let tup = (1, 6.4, "hello");
// let (x,z,y) = tup;
// assert_eq!(x, 1);
// assert_eq!(y, "hello");
// assert_eq!(z, 6.4);

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
// let (x, y, z);
// (y,z,x) = (1, 2, 3);
// assert_eq!(x, 3);
// assert_eq!(y, 1);
// assert_eq!(z, 2);

//**************************************************************************************************
// EXAMPLE NO.6 TUPLE FUNCTION
//**************************************************************************************************
// let (x, y) = sum_multiply((3,2));
// assert_eq!(x, 5);
// assert_eq!(y, 6);
 
fn sum_multiply(nums: (i32, i32)) -> (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
 
println!("Finished");
 

    // Fill the blank
 

    // Fill the blank to make the code work
 
, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13
 
// weirdly that the index of tuple start with 1
 

    println!("Success!");
 
Tuple 
* Compound data type that store different variable with different type.
* stored as a fixed size contiguous block of memory on the stack.
* (T, T, T)
 
fn first_letter(s: &str) -> &str {
    &s[..1]
}
 
// let arr = [1, 2, 3];
// // The length of slice is not known at comply time.
// // so I use & to borrow the value of the array.
// let s1: &[i32] = &arr[0..2];
// let s2: &str = "hello, world";

//**************************************************************************************************
// EXAMPLE NO.2 TOTAL NUMBER, STD MEM SIZE OF VAL
//**************************************************************************************************
// let arr: [char; 3] = ['', '', ''];
// let slice = &arr[..2];
// println!("slice = {:?}",slice);
// println!("Count Byte in slice = {}",std::mem::size_of_val(&slice));

//**************************************************************************************************
// EXAMPLE NO.3 &
//**************************************************************************************************
// let arr: [i32; 5] = [1, 2, 3, 4, 5];
// // do not specify the size of the slice.
// // the size of slice is unknown.
// let slice: &[i32] = &arr[1..4];
// assert_eq!(slice, &[2, 3, 4]);

//**************************************************************************************************
// EXAMPLE NO.4 SLICE STARTING FROM THE FIRST ELEMENT.
//**************************************************************************************************
// let s = String::from("hello");
// let slice1 = &s[0..2];
// let slice2 = &s[..2];
// assert_eq!(slice1, slice2);

//**************************************************************************************************
// EXAMPLE NO.5 SLICE STARTING FROM THE FIRST ELEMENT.
//**************************************************************************************************
// let charchar="".bytes();
// println!(" = {:?}",charchar);
// //  = Bytes(Copied { it: Iter([228, 189, 160]) })
// let s = "";
// let slice = &s[0..3];
// assert!(slice == "");

//**************************************************************************************************
// EXAMPLE NO.6 SLICE STARTING FROM THE FIRST ELEMENT.
//**************************************************************************************************
let mut s = String::from("hello world");
let letter = first_letter(&s);
println!("the first letter is: {}", letter);
println!("Previous s = {}",s);
s.clear(); // make s = "" 
s="Its me DIO!".to_string();
println!("Current s = {}",s);
 
println!("the first letter is: {}", letter);
 
// Modify this line to make the code work
 
.as_bytes()
 
    // Fill the blank to make the code work, DON'T USE 0..2 again
 
 as str
 
// let arr: [i32;5] = [1, 2, 3, 4, 5];
// assert!(arr.len() == 5);

//**************************************************************************************************
// EXAMPLE NO.2 SIZE OF ARRAY
//**************************************************************************************************
// let arr: [char; 3] = ['a', 'b', 'c'];
// assert!(std::mem::size_of_val(&arr) == arr.len()*4);

//**************************************************************************************************
// EXAMPLE NO.3 CREATE THE ARRAY WITH SAME ELEMENT
//**************************************************************************************************
// // https://doc.rust-lang.org/rust-by-example/primitives/array.html
// let list: [i32; 100] = [1;100] ;
// assert!(list[0] == 1);
// assert!(list.len() == 100);

//**************************************************************************************************
// EXAMPLE NO.4 LET THE_FIRST = ARRAY[0]
//**************************************************************************************************
// let arr = ['a', 'b', 'c'];
// let ele = arr[0]; // Only modify this line to make the code work!
// println!("{}",ele);
// assert!(ele == 'a');

//**************************************************************************************************
// EXAMPLE NO.
//**************************************************************************************************
// let names = [String::from("Sunfei"), "Sunface".to_string()];
// // `Get` returns an Option<T>, it's safe to use
// let name0 = names.get(0).unwrap();
// let _name1 = &names[1];
// // But indexing is not safe
// // let _name2 = &names[2];
// println!("{}",name0);
// println!("{}",_name1);
// println!("Success!");
 
//**************************************************************************************************
// EXAMPLE NO.3 CREATE THE ARRAY WITH SAME ELEMENT
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.3 CREATE THE ARRAY WITH SAME ELEMENT
//**************************************************************************************************

//**************************************************************************************************
// EXAMPLE NO.3 CREATE THE ARRAY WITH SAME ELEMENT
//**************************************************************************************************

 
// But indexing is not safe
 
Success!
 
3 CREATE THE ARRAY WITH SAME ELEMENT
 
    
    // Fill the blank
    // Arrays are stack allocated, 
    // `std::mem::size_of_val` returns the bytes which an array occupies
    // A char takes 4 bytes in Rust: Unicode char
 

    // Modify the code below to make it work
 


    // Fill the blank with proper array type
 
//**************************************************************************************************
// EXAMPLE NO.1, BOX<STR> AND &STR
//**************************************************************************************************
// let name:Box<str>="Jojo".into();
// greetings_box(name);
// // Hello, Jojo
// let name:&str="Jojo";
// greetings_str(name);
// // Hello, Jojo

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
// let s = String::from("I like dogs");
// // Allocate new memory and store the modified string there
// let s1 = s.replace("dogs", "cats");
// assert_eq!(s1, "I like cats");
// println!("{}",s1);

//**************************************************************************************************
// EXAMPLE NO.3 CONCAT STRING
//**************************************************************************************************
// let s1:String = String::from("hello,");
// let s2:String = String::from("world!");
// // let s3 = s1+s2; // invalid
// let s3:String = format!("{}{}",s1,s2); // valid
// let s3:String = s1+&s2;                // valid
// let s1:String = String::from("hello,");
// let s3:String = s1+s2.as_str();        // valid

//**************************************************************************************************
// EXAMPLE NO.4 INSERT STRING::FROM AS THE INPUT OF THE FUNCTION
//**************************************************************************************************
// let s = "hello, world";
// greetings_string(String::from(s))

//**************************************************************************************************
// EXAMPLE NO.5 CONVERT STRING TO &STR
//**************************************************************************************************
// let s = "hello, world".to_string();
// let s1: &str = s.as_str();
// let s1: &str = &s;

//**************************************************************************************************
// EXAMPLE NO.6 CHAR IN BYTES
//**************************************************************************************************
// // https://stackoverflow.com/questions/56485167/how-to-format-a-byte-into-a-2-digit-hex-string-in-rust
// // https://stackoverflow.com/questions/53353764/how-to-convert-a-very-large-decimal-string-to-hexadecimal
// let b_t='t' as u32;
// println!("b_t (dec) = {}",b_t);
// // b_t (dec) = 116
// let my_string = b_t.to_string();  // `parse()` works with `&str` and `String`!
// let my_int = my_string.parse::<u128>().unwrap();
// let my_hex = format!("{:X}", my_int);
// println!("b_t (hex) = {}", my_hex);     
// // b_t (hex) = 74
// // You can use escapes to write bytes by their hexadecimal values
// // Fill the blank below to show "I'm writing Rust"
// let byte_escape = "I'm writing Ru\x73\x74!";
// println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);
// let unicode_codepoint = "\u{211D}";
// let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";
// println!("Unicode character {} (U+211D) is called {}",
//             unicode_codepoint, character_name );
// let long_string = "String literals
//                     can span multiple lines.
//                     The linebreak and indentation here \
//                      can be escaped too!";
// println!("{}", long_string);

//**************************************************************************************************
// EXAMPLE NO.7 BACKWARD SLASK, ESCAPED
//**************************************************************************************************
//let raw_str = "Escapes don't work here: \x3F \u{211D}";
//println!("{}",raw_str);
//assert_eq!(raw_str, "Escapes don't work here: ? ");
////
//let raw_str = r"Escapes don't work here: \x3F \u{211D}";
//println!("{}",raw_str);
//// "Escapes don't work here: \x3F \u{211D}"
////
//// If you need quotes in a raw string, add a pair of #s
//let quotes = r#"And then I said: "There is no escape!""#;
//println!("{}", quotes);
////
//// If you need "# in your string, just use more #s in the delimiter.
//// You can use up to 65535 #s.
//let delimiter = r###"A string with "# in it. And even "##!"###;
//println!("{}", delimiter);
////
//let long_delimiter = "Hello, \"##\"";
//assert_eq!(long_delimiter, "Hello, \"##\"");

//**************************************************************************************************
// EXAMPLE NO.8 CONVERT CHAR TO U8 TO BINARY NUMBER, INDEXING CHAR IN STRING
//**************************************************************************************************
// let message = String::from("hi,");
// // convert char to u8 and binary number
// //println!("message.bytes() = {:?}",message.bytes());
// let mut count:u8=0;
// for b in message.bytes(){
//     println!("({}.) {:#b} = {} = {}",count,b,b,format!("{:?}",b as char));
//     // (1.) 0b1101000 = 104 = 'h'
//     // (2.) 0b1101001 = 105 = 'i'
//     // (3.) 0b101100 = 44 = ','
//     // (4.) 0b11100100 = 228 = ''
//     // (5.) 0b10111000 = 184 = ''
//     // (6.) 0b10101101 = 173 = '\u{ad}'
//     // (7.) 0b11100101 = 229 = ''
//     // (8.) 0b10011011 = 155 = '\u{9b}'
//     // (9.) 0b10111101 = 189 = ''
//     count+=1;
// };
// // convert u8 to char
// //https://stackoverflow.com/questions/35833329/how-to-convert-i32-to-a-string-representing-the-ascii-character
// let target_number:u8=104;
// let s_str: String = format!("{:?}",target_number as char);
// println!("'h' = {s_str}");
// println!("h = {}",&message[0..1]);
// println!(" = {}",&message[3..6]);
// let h = &message[0..1]; 
// assert_eq!(h, "h");
// let h1 = &message[3..6]; 
// assert_eq!(h1, "");
// println!("Success");

//**************************************************************************************************
// EXAMPLE NO.9 STRING_SOMETHING.CHARS()
//**************************************************************************************************
// for c in "".chars() {
//     println!("{}", c)
// }
 
fn greetings_box(s: Box<str>) {
    println!("Hello, {}",s);
}
fn greetings_str(s: &str) {
    println!("Hello, {}",s);
}

fn greetings_string(s: String) {
    println!("{}", s)
}



 

// slice string
 
nly takes 1 byte in UTF8 format
 
// Modify this line to fix the error, tips: `h` o
 
kes 3 bytes in UTF8 format
 
// Modify this line to fix the error, tips: ``  ta
 
]
 
count+=1;
 
pub fn leading_bits(arr: &[u8; 32]) -> u32 {
    // https://stackoverflow.com/questions/74495816/how-to-convert-u8-32-type-to-binary
    let mut count = 0;
    for x in arr {
        let bits = x.leading_zeros();
        count += bits;
        if bits != 8 {
            break;
        }
    }
    count
}
 
; 32
 
// Fill the blank
 
// Modify above line to make it work
 
println!("{}",long_delimiter);
 
 let raw_str = r"Escapes don't work here: \x3F \u{211D}";
 
// Modify above line to make it work
 
// Fill the blank
 
// If you need "# in your string, just use more #s in the delimiter.
// You can use up to 65535 #s.
 
__
 
.to_string()
 

// ...Or Unicode code points.
 
             // 116
 
// let b_t=18;
 
:String
 
"t".to_string()
 
 as u16
 
t' as u16
 
println!("b_1 (dec) = {}",b_t);
 
 (hex)
 
println!("b_1 (dec) = {}",b_t);
 
:#03
 
.to_hex()
 
.as_slice()
 
:char
 
 as u16
 
let b_t:char='t';
println!("{}",b_t as u16);
 
.as_str()
 
let s3:String = s1+s2.as_str();
 
let mut s = String::from("hello");
s.push(',');
s.push_str(" world");
s.push_str("!");
 
.to_string()
 
, BOX<STR> AND &STR
 
li
 
.into()
 
//**************************************************************************************************
// CONVERT &STR TO STRING
//**************************************************************************************************

 
let no_permission:&str="git cimmit -m 'Create Cool Project'";
let have_permission:String="git cimmit -m 'Create Cool Project'".to_string();
let fork1:String=get_permission(no_permission);
let fork2:String=get_permission(&have_permission);
 
fn get_permission(a:&str)->String{
    return format!("{}",a)
}
 
.to_string()
 
//**************************************************************************************************
// PRINTLN EACH CHAR IN &STR
//**************************************************************************************************

 
// There are some character that terminal connot display
// because this loop iterate over the unicode scalar value of the string 
// instead of the character.
println!("' = Hello'.chars()");
for b in " = Hello".chars(){
    println!("{}",b);
    // 
    // 
    //
    // ...
    // o
};
 
println!("' = Hello'.chars()");
for b in " = Hello".graphemes(true){
    println!("{}",b);
    // 
    // 
    //
    // ...
    // o
};
 
use unicode_segmentation::UnicodeSegmentation;
 
use unicode_segmentation::;;
 
::Unicode_segmentation
 
 
 
// converting the &str to tupl
 
println!("message.chars() = {}"," = Hello".chars().to_string());
 
let firstchar:char='';
println!("firstchar = {}",firstchar as u8);
// firstchar = 42
 
// 224
// 184
// ...
// 111
 
/*
 
let get8thbytes=first10thaichar[7];
 
let get8thbytes=&first10thaichar.7;
 
/*
4*0-4*1
4*1-4*2
4*2-4*3
*/
 
3
 
let first10thaichar:&str = "";
 
let firstthaichar_as_bytes:String = "\u{"+firstthaichar.to_string()+"}";
 

 
let helloworld:String = ["Hello"," ","World"].concat();
let helloworld:String = format!("{} {}","Hello", "World");
let helloworld:&str = concat!("Hello"," ","World");
let hello:String = String::from("Hello");
let helloworld:String = hello+" World";
 
FORMAT, 
 
let first_commit:String = String::from("git commit -c 'Creating New Project!'");
let second_commit:String = String::from("git commit -c 'developing version 2'");
let thrid_commit:&str = "git commit -c 'developing version 3'";
// FORMAT
let project_development:String = format!(
    "{}\n{}\n{}\n{}",
    first_commit,
    second_commit,
    thrid_commit,
    "git push origin main"
);
println!("{}",project_development);
// CONCAT
let project_development:&str = [
    first_commit,
    second_commit,
    thrid_commit.to_string().push_str("git push origin main")
].concat();
println!("{}",project_development);
 
let first_commit:String = String::from("git commit -c 'Creating New Project!'");
let second_commit:String = String::from("git commit -c 'developing version 2'");
let thrid_commit:&str = "git commit -c 'developing version 3'";
// FORMAT
let project_development:String = format!(
    "{}\n{}\n{}\n{}",
    first_commit,
    second_commit,
    thrid_commit,
    "git push origin main"
);
println!("{}",project_development);
// CONCAT
let project_development:&str = [
    first_commit,
    second_commit,
    thrid_commit.to_string().push_str("git push origin main")
].concat();
println!("{}",project_development);
}

 
    
 
.to_string()
 
    "{}\n{}\n{}\n{}",
 
String::from(
 
let no_permission_to_edit:&str = "git commit -c 'Creating New Project!'";
 
println!("{}",project_development);
project_development.push_str(" & git commit -c 'develop version 2'");
println!("{}",project_development);
project_development.replace_range(..,"git push origin main");
println!("{}",project_development);
 
let no_permission_to_edit:&str = "git commit -c 'Creating New Project!'";
let mut project_development:String = String::from(no_permission_to_edit);
println!("{}",project_development);
project_development.push_str(" & git commit -c 'develop version 2'");
println!("{}",project_development);
project_development.replace_range(..,"git push origin main");
println!("{}",project_development);
 
let fork_02:String = no_permission_to_edit.to_string();
let fork_03:String = no_permission_to_edit.to_owned();
let audience_only_read_github:&str = &fork_03[..];
let deployment:&str = &fork_03[13..];
let learning_git:&str = &fork_03[..13];
let commitment:&str = &fork_03[4..10];
let vitamin_c:&str = &commitment[..];
println!("let audience_only_read_github:&str = {}",audience_only_read_github);
println!("let edit_03:String = {}",fork_03);
println!("let deployment:&str = {}",deployment);
println!("let deployment:&str = {}",learning_git);
println!("let commitment:&str = {}",commitment);
println!("let vitamin_c:&str = {}",vitamin_c);
 
let fork_01:String = String::from(no_permission_to_edit);
let fork_02:String = no_permission_to_edit.to_string();
let fork_03:String = no_permission_to_edit.to_owned();
let audience_only_read_github:&str = &fork_03[..];
let deployment:&str = &fork_03[13..];
let learning_git:&str = &fork_03[..13];
let commitment:&str = &fork_03[4..10];
let vitamin_c:&str = &commitment[..];
println!("let audience_only_read_github:&str = {}",audience_only_read_github);
println!("let edit_03:String = {}",fork_03);
println!("let deployment:&str = {}",deployment);
println!("let deployment:&str = {}",learning_git);
println!("let commitment:&str = {}",commitment);
println!("let vitamin_c:&str = {}",vitamin_c);
 
    Capacity: 11
 
(length) of characters (in UTF8, each character has 1-4 
 
English 
 
English 
 
, allocate in heap
 

// use rand::Rng;
// use std::cmp::Ordering;
// use std::fs::File;
// use std::io;
// use std::io::{BufRead, BufReader, ErrorKind, Write};
// use std::ops::{Range, RangeInclusive};

fn push_str(s: &mut String) {
    s.push_str("world")
}
fn borrow_object(s: String) {}
fn borrow_and_object(s: &String) {}
fn borrow_mut_object(s: &mut String) {}
 
PRINTING THE MEMORY ADDRESS
 
// let x = 112;
// let p = &x;
// println!("the memory address of x is {:p}", p); 
// println!("the value of x is {}", p); 
// println!("the value of x is {:}", p); 

//**************************************************************************************************
// EXAMPLE NO.2 STAR (*) = ACCESSING THE ORIGINAL VALUE
//**************************************************************************************************
// let x = 5;
// let y = &x;
// //assert_eq!(5, y); // invalid
// assert_eq!(5, x);   // valid because x = 5
// assert_eq!(&5, y);  // valid because &5 = y  = the reference of 5
// assert_eq!(&x, y);  // valid because &x = y  = the reference of 5
// assert_eq!(&x, &5); // valid because &x = &5 = the reference of 5
// // * mean to access the original value that the pointer refer to.
// assert_eq!(5, *y);  // valid because 5 = *y  = the original value of 5
// assert_eq!(5, *&5); // valid because 5 = *&5 = the original value of 5
// assert_eq!(5, *&x); // valid because 5 = *&x = the original value of 5

//**************************************************************************************************
// EXAMPLE NO.3 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// // You must specify if the input value of the function
// // is mutable or immutable reference, or non-reference variable.
// // And the input value must match with the input attribute of the function.
// push_str(&mut s);
// println!("Success!");

//**************************************************************************************************
// EXAMPLE NO.4 ALL OF THE MUTABLE VARIABLE CANNOT HAVE IMMUTABLE REFERENCE.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// let p = &mut s;
// p.push_str("world");

//**************************************************************************************************
// EXAMPLE NO.5 REF IS THE SAME AS &, EXCEPT IT MAKE CODE MORE READABLE IN SOMECASE.
//**************************************************************************************************
// let c = '';
// let r1 = &c;
// let ref r2 = c;
// assert_eq!(r1,r2);

//**************************************************************************************************
// EXAMPLE NO.6 USING MULTIPLE IMMUTABLE REFERENCE.
//**************************************************************************************************
// let mut s = String::from("hello");
// let r1 = & s;
// let r2 = & s;
// println!("{}, {}", r1, r2);

//**************************************************************************************************
// EXAMPLE NO.7 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let  s = String::from("hello, ");
// borrow_object(s);
// let mut s = String::from("hello, ");
// borrow_mut_object(&mut s);
// println!("No Error!");

//**************************************************************************************************
// EXAMPLE NO.8 SPECIFY IF THE INPUT VALUE IS REFERENCE OR NOT.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// borrow_and_object(&s);
// s.push_str("world");

//**************************************************************************************************
// EXAMPLE NO.9 VALID BECAUSE THE PREVIOUS MUTABLE REFERENCE IS NOT LONGER USED.
//**************************************************************************************************
// let mut s = String::from("hello, ");
// let r1 = &mut s;
// r1.push_str("world");
// let r2 = &mut s;
// r2.push_str("!");
// println!("{}",r2);
 
//**************************************************************************************************
// EXAMPLE NO.9 VALID BECAUSE THE PREVIOUS MUTABLE REFERENCE IS NOT LONGER USED.
//**************************************************************************************************

 
borrow_object(s);
 
&mut 
 
: &mut String
 
// Fill the blankdont change other code
 
    // Fill the blank to make it work
 
//assert_eq!(5, y); // invalid
 
in
 

    // Modify this line only
 
memory addres
 
   // Fill the blank
 
fn writing()->String{
    let text=String::from("Harry Potter");
    text    // allow
    //&text // does not allow because when text is not longer use
            // the reference that borrow the text cannot
            // reference the text anymore, causing dangling problem. 
}
 
    let book = writing();      
 
// In order to use multiple immutable and a mutable reference in different time
// the target variable must be mutable.
let mut exam = String::from("f'(x) = lim_{h->0} ( f(x+h) - f(x) ) / (h) ");
let honeststudent1=&exam;   // Rust does not allow both immutable and mutable reference.
let honeststudent2=&exam;   // Rust allows multiple immutable references.
println!("{}, {}",honeststudent1,honeststudent2);
// the cheater takes alone exam after 2 honest students finished the exam.
// So the cheater cannot cheat on the exam.
let cheater=&mut exam;      // Rust allows one mutable reference.
println!("{}",cheater);        
 
alone 
 
use std::mem::size_of_val;
use std::env;
 
env::remove_var(honeststudent1);
env::remove_var(honeststudent2);
 
fn add_his_famous_song(album: &mut String,songname:&str){
    album.push_str(songname)
}
 
println!("");
 
use std::mem::size_of_val;
 
.to_string()
 
songname:String
 
// another example
 
fn add_his_famous_song(album: String,songname:&str)->String{
    // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
    let mut album=album;
    let songname:&str=songname;
    album.push_str(songname)
}
 
    completealbum
 
let completealbum:String=
 
String::from(
 
String::from(
 
", One day you doing to die!"
 
.to_string()
 
.push_str(
 
mut 
 
mut 
 
&mut
 

fn take_ownership(s: String)->String {
    println!("{}", s);
    s
}
fn give_ownership() -> String {
    let s = String::from("Hello world");
    // Convert String to Vector u8
    // into_bytes switch the owner of HelloWorld from s to _s
    // as_bytes create new variable, and does not effect the owner ship of HelloWorld.
    let _s = s.as_bytes();
    s
}
fn print_str(s: String) ->String {
    println!("{}",s);
    s
}
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************
    // This cause error, because the variable can only have 1 ownership.
    // and String variable is heap variable that only be access by pointer.
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}, {}",x, y);

    // Solution 1
    // clone copy the heap data.
    // beware that the heap data is memory expensive
    // let x = String::from("Hello world");
    // let y = x.clone();
    // println!("{}, {}",x, y);

    // Solution 2
    // let x = String::from("Hello world");
    // let y = String::from("Hello world");
    // println!("{}, {}",x, y);

    // Solution 3
    // let x = String::from("Hello world");
    // println!("{}",x);

    // Solution 4
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}",y);

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
    //let s1 = String::from("Hello world");
    //let s2 = take_ownership(s1);
    //println!("{}", s2);

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
    //let s = give_ownership();
    //println!("{}", s);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
    // let s = String::from("Hello World");
    // let ss = print_str(s);
    // println!("{}", ss);

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
//let tupless:(i32,i32,i32,String,(),String)= (255,0,0,"Red".to_string(),()," is my Lucky Color!".to_string());
//let x:(i32,i32,(),&str) = (1, 2, (), "hello");
//let y = x;
//println!("{:?} == {:?}", x, y);
//let mut mbti:&str="intp";
//mbti="lgbt";
//mbti="UFO";
//mbti="pseudoscience";
//println!("{}",mbti);
/*
The similarity between &str and String
 * Both store string

The different between &str and String
 * String have unknown size
 * &str have fixed size.
*/

//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let s = String::from("Hello ");
// let mut s1 = s;
// s1.push_str("World!");

//**************************************************************************************************
// EXAMPLE NO.7
//**************************************************************************************************
// https://doc.rust-lang.org/rust-by-example/std/box.html
// By default the value is stored in stack.
// Box allow the value store in heap.
let x = Box::new(5);
println!("x = {}",x);
println!("*x = {}",*x);
let mut y=x.clone();
*y = 4;
assert_eq!(*x, 5);
// y is equal 5_i32
// y is stored in Stack.
let y=*x;
println!("y = {}",y);
println!("{}",x);

//**************************************************************************************************
// EXAMPLE NO.8 STRUCT
//**************************************************************************************************
// struct Coffee{
//     name:String,
//     cost:Box<i32>,
//     caffeine:Box<f32>,
//     sugar:f32,
//     water:f32,
// };
// let jojocofee=Coffee{
//     name:String::from("Yuzu Coffee"),
//     cost:Box::new(120),
//     caffeine:Box::new(2.5),
//     sugar:1.5,
//     water:4.0
// };
// println!("jojocofee.name = {}",jojocofee.name);
// println!("jojocofee.cost = {}",jojocofee.cost);
// println!("jojocofee.caffeine = {}",jojocofee.caffeine);
// let Coffee {name,cost,ref caffeine,sugar, ref water} = jojocofee;
// println!("let Coffee {{ name ,cost,ref caffeine,sugar, ref water}} = jojocofee;");
// // println!("jojocofee.name = {}",jojocofee.name); // Error
// println!("jojocofee.name = {}",name);
// println!("jojocofee.cost = {}",cost);
// println!("jojocofee.caffeine = {}",caffeine);
// println!("jojocofee.water = {}",water);

//**************************************************************************************************
// EXAMPLE NO.9
//**************************************************************************************************
// let t = (String::from("hello"), String::from("world"));
// // _s borrow the value of t
// let _s = &t;
// println!("{:?}", t);
// // let _s = String::from("hello")
// let _s = t.0;
// // t.1 == String::from("world")
// println!("{:?}", t.1);


//**************************************************************************************************
// EXAMPLE NO.10
//**************************************************************************************************
let t = (String::from("hello"), String::from("world"));
// Fill the blanks
let (s1, s2) = &t; // t.clone()
println!("{:?}, {:?}, {:?}", s1, s2, t);
 
//**************************************************************************************************
// EXAMPLE NO.1
//**************************************************************************************************
    // This cause error, because the variable can only have 1 ownership.
    // and String variable is heap variable that only be access by pointer.
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}, {}",x, y);

    // Solution 1
    // clone copy the heap data.
    // beware that the heap data is memory expensive
    // let x = String::from("Hello world");
    // let y = x.clone();
    // println!("{}, {}",x, y);

    // Solution 2
    // let x = String::from("Hello world");
    // let y = String::from("Hello world");
    // println!("{}, {}",x, y);

    // Solution 3
    // let x = String::from("Hello world");
    // println!("{}",x);

    // Solution 4
    // let x = String::from("Hello world");
    // let y = x;
    // println!("{}",y);

//**************************************************************************************************
// EXAMPLE NO.2
//**************************************************************************************************
    //let s1 = String::from("Hello world");
    //let s2 = take_ownership(s1);
    //println!("{}", s2);

//**************************************************************************************************
// EXAMPLE NO.3
//**************************************************************************************************
    //let s = give_ownership();
    //println!("{}", s);

//**************************************************************************************************
// EXAMPLE NO.4
//**************************************************************************************************
    // let s = String::from("Hello World");
    // let ss = print_str(s);
    // println!("{}", ss);

//**************************************************************************************************
// EXAMPLE NO.5
//**************************************************************************************************
//let tupless:(i32,i32,i32,String,(),String)= (255,0,0,"Red".to_string(),()," is my Lucky Color!".to_string());
//let x:(i32,i32,(),&str) = (1, 2, (), "hello");
//let y = x;
//println!("{:?} == {:?}", x, y);
//let mut mbti:&str="intp";
//mbti="lgbt";
//mbti="UFO";
//mbti="pseudoscience";
//println!("{}",mbti);
/*
The similarity between &str and String
 * Both store string

The different between &str and String
 * String have unknown size
 * &str have fixed size.
*/

//**************************************************************************************************
// EXAMPLE NO.6
//**************************************************************************************************
// let s = String::from("Hello ");
// let mut s1 = s;
// s1.push_str("World!");

//**************************************************************************************************
// EXAMPLE NO.7
//**************************************************************************************************
// https://doc.rust-lang.org/rust-by-example/std/box.html
// By default the value is stored in stack.
// Box allow the value store in heap.
let x = Box::new(5);
println!("x = {}",x);
println!("*x = {}",*x);
let mut y=x.clone();
*y = 4;
assert_eq!(*x, 5);
// y is equal 5_i32
// y is stored in Stack.
let y=*x;
println!("y = {}",y);
println!("{}",x);

//**************************************************************************************************
// EXAMPLE NO.8 STRUCT
//**************************************************************************************************
// struct Coffee{
//     name:String,
//     cost:Box<i32>,
//     caffeine:Box<f32>,
//     sugar:f32,
//     water:f32,
// };
// let jojocofee=Coffee{
//     name:String::from("Yuzu Coffee"),
//     cost:Box::new(120),
//     caffeine:Box::new(2.5),
//     sugar:1.5,
//     water:4.0
// };
// println!("jojocofee.name = {}",jojocofee.name);
// println!("jojocofee.cost = {}",jojocofee.cost);
// println!("jojocofee.caffeine = {}",jojocofee.caffeine);
// let Coffee {name,cost,ref caffeine,sugar, ref water} = jojocofee;
// println!("let Coffee {{ name ,cost,ref caffeine,sugar, ref water}} = jojocofee;");
// // println!("jojocofee.name = {}",jojocofee.name); // Error
// println!("jojocofee.name = {}",name);
// println!("jojocofee.cost = {}",cost);
// println!("jojocofee.caffeine = {}",caffeine);
// println!("jojocofee.water = {}",water);

//**************************************************************************************************
// EXAMPLE NO.9
//**************************************************************************************************
// let t = (String::from("hello"), String::from("world"));
// // _s borrow the value of t
// let _s = &t;
// println!("{:?}", t);
// // let _s = String::from("hello")
// let _s = t.0;
// // t.1 == String::from("world")
// println!("{:?}", t.1);


//**************************************************************************************************
// EXAMPLE NO.10
//**************************************************************************************************
let t = (String::from("hello"), String::from("world"));
// Fill the blanks
let (s1, s2) = &t; // t.clone()
println!("{:?}, {:?}, {:?}", s1, s2, t);
 
2 Rules of Borrowing
* In anytime, ypu can have one of 2 things
 1. One mutable reference 
 2. any number of immutable reference 
* Reference must always be valid. (pointer must reference to the available data.)
 
// input borrow
 
 *
 
 by
 
let 
 
.clone()
 
// Modify this line only, don't use `_s`
 
println!("jojocofee.caffeine = ",jojocofee.caffeine);
 
println!("jojocofee.caffeine = ",jojocofee.water);
 
println!("let jojocofee=Coffee\{
    name:String::from('Yuzu Coffee'),
    cost:Box::new(120),
    caffeine:Box::new(2.5),
    sugar:1.5,
    water:4.0
};");
 
"let jojocofee=Coffee\{
    name:String::from('Yuzu Coffee'),
    cost:Box::new(120),
    caffeine:Box::new(2.5),
    sugar:1.5,
    water:4.0
};"
 
jojocofee.
 
ojocofee.
 
jojocofee.
 
ame, cost, caffeine, ref sugar, water
 
ref 
 
let x = Box::new(5);
 
 mut
 
 EXAMPLE NO.6
 
.to_string()
 
:(i32,i32,(),&str)
 
.to_string()
 
.to_string()
 
x, 
 
, {}
 
    //let y = x;
 
//, y);
 

    // Use as many approaches as you can to make it work
 
    let s3 = 
 
    // might do other things
 
UNIT
 
Example No.2
 
: SCOPE
 
// 2. drop input previous ownership.
 
// copy the data with fixed size
 
Size of message is 24 bytes
 
"Hello" belong to Heap.
 
*/
 
|
|
|
 
 len
 
// Its pointer indicate the position of "Hello"
 
  
 
   //**************************************************************************************************
    // CASE 01: EXPRESSION
    //**************************************************************************************************

    //let x = 5u32;
    //let y = {
    //    let x_squared = x * x;
    //    let x_cube = x_squared * x;
    //    x_cube + x_squared + x
    //};
    //println!("x is {:?}", x);
    //println!("y is {:?}", y);

    //**************************************************************************************************
    // CASE 02
    //**************************************************************************************************
    // let v = {
    //    let mut x = 1;
    //    x + 2
    //    // x +=2 // is wrong
    // };
    // println!("{}",v);
    // let statement_v = {
    //    let mut x = 1;
    //    x += 2;
    //    // return unit type
    // };


    //**************************************************************************************************
    // CASE 03: MATCH
    //**************************************************************************************************
    let input=1;
    match input{
        1=>println!("low"),
        2=>println!("median"),
        3=>println!("high"),
        _ =>println!("Invalid")
    };

    //**************************************************************************************************
    // CASE 04: DIVERGE FUNCTION AND PANIC
    //**************************************************************************************************
    // never_return();

    //**************************************************************************************************
    // CASE 05: MATCH AND PANIC
    //**************************************************************************************************
    // let b = false;
    // let _v = match b {
    //     // return 1
    //     true => 1,
    //     // return error.
    //     false => {
    //         println!("Success!");
    //         panic!("we have no value for `false`, but we can panic");
    //     }
    // };
 
// This is diverge function
fn never_return() -> ! {
    // panic make the complier show error.
    panic!("SOS");
}

fn get_option(tp: u8) -> Option<i32> {
    match tp {
        1 => {
            // TODO
        }
        _ => {
            // TODO
        }
    };
    
    // Rather than returning a None, we use a diverging function instead
    never_return_fn()
}

// IMPLEMENT this function in THREE ways
fn never_return_fn() -> ! {
    panic!("SOS");
    //unimplemented!();
    //todo!();
}

 
// Diverging functions can also be used in match expression to replace a value of any value
 
the fn signatures
 
    // Implement this function, don't modify 
 
"This function never returns!"
 
//
 
    println!("z is {:?}", z);
 
    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x
    };
 

        // This expression will be assigned to `y`
 
fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}

fn implicitly_ret_unit() {
    println!("I will return a ()");
}

// Don't use this one
fn explicitly_ret_unit() -> () {
    println!("I will return a ()");
}

// Explicitly return i32
fn one984(justthe:i32,two:i32)->i32{
    let ofus:i32=1;
    justthe+two+ofus
}
 
    //**************************************************************************************************
    // CASE 01: SIZE OF CHAR IS 4
    //**************************************************************************************************

    // let c1 = 'a';
    // let c2 = '';
    // println!("bit size of c1 = {}",size_of_val(&c1)); // 4
    // println!("bit size of c2 = {}",size_of_val(&c2)); // 4

    //**************************************************************************************************
    // CASE 02: SINGLE QUOTE = CHAR , DOUBLE QUOTE = &STR
    //**************************************************************************************************
    // let c1:char='a';
    // let c2:&str="a";
    // println!("Type of c1 = {}",type_of(&c1));   // char
    // println!("Type of c2 = {}",type_of(&c2));   // &str

    //**************************************************************************************************
    // CASE 03: CONDITION
    //**************************************************************************************************

    // let thetruth:bool=true;
    // //let thetruth:bool=false;
    // let myname:&str="CheChe";
    // if myname=="Cheche"{
    //     println!("God.");
    // }
    // else{
    //     println!("Satan.");
    // };

    //**************************************************************************************************
    // CASE 03: AND
    //**************************************************************************************************
    // let f = false;
    // let t = true && false;
    // println!("{} == {}",f,t);

    //**************************************************************************************************
    // CASE 04: UNIT TYPE
    //**************************************************************************************************
    // The unit type is the data type that have 0 bits.
    // The function that does not return any value
    // will always return unit type.
    // let emptyset: () = (); 
    let tuplee: (i32,i32,i32)=(22,23,24);
    // println!("{}",one984(2,2));

    //**************************************************************************************************
    // CASE 05: SIZE OF UNIT TYPE
    //**************************************************************************************************
    let unit: () = ();
    println!("{}",size_of_val(&unit));  // 0
 
,thetruth
 
 tell {}
 
,thetruth
 
//let y: &[u8] = &x;
 
 and {}
 

fn type_of<T>(_: &T) -> String {
    format!("{}", std::any::type_name::<T>())
}
 
    //**************************************************************************************************
    // CASE 01: ASSIGNED VALUE AS TYPE
    //**************************************************************************************************

    //#v = 38 that is assigned as u16
    //#38 is assigned as u8
    //let v: u16 = 38_u8 as u16;

    //println!("Success!");

    //**************************************************************************************************
    // CASE 02: DEFAULT VALUE
    //**************************************************************************************************
    // let x = 5;
    // println!("{}=={}",
    //     "i32".to_string(), 
    //     type_of(&x).to_string());

    //**************************************************************************************************
    // CASE 03: CHECKED_ADD AND UNWRAP
    //**************************************************************************************************
    // let v1 = 251_u16 + 8;
    // let v2 = i16::checked_add(251, 8).unwrap();
    // println!("{},{}",v1,v2);

    //**************************************************************************************************
    // CASE 04: 0XFF
    //**************************************************************************************************
    //#hexadecimal numeral system
    // println!("0xff = {}",0xff); // = 255
    // println!("0o77 = {}",0o77); // = 63
    // println!("0b1111_1111 = {}",0b1111_1111); // = 255

    //**************************************************************************************************
    // CASE 05: FLOATING POINT
    //**************************************************************************************************
    //let x64 = 1_000.000_1;
    //println!("{}==f64",type_of(&x64));

    //**************************************************************************************************
    // CASE 06: FLOATING POINT PRECISION
    //**************************************************************************************************
    //println!("{}=={}",0.1_f32+0.2_f32,0.3_f32);
    //println!("{}=={}",0.1 as f32+0.2 as f32,0.3 as f32);

    //**************************************************************************************************
    // CASE 07: FOR LOOP
    //**************************************************************************************************
    //let mut sum=0;
    //for i in 0..10{
    //    sum+=i;
    //    //println!("{}",i) // 0,1,...,9
    //};
    //let sigma=(10*9)/2;
    //println!("{}=={}",sum,sigma)

    //for i in 0..=10{
    //    println!("{}",i) // 0,1,...,10
    //};

    //for i in RangeInclusive::new(1, 5){
    //    println!("{}",i); // 1,2,...,5
    //};

    //**************************************************************************************************
    // CASE 08: RANGE AND RANGEINCLUSIVE
    //**************************************************************************************************
    // https://doc.rust-lang.org/std/ops/struct.Range.html
    // (3..5) == Range { start: 3, end: 5 }
    // assert_eq!((3..5), Range { start: 3, end: 5 });

    // https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html
    // assert_eq!((3..=5), RangeInclusive::new(3, 5));
    // assert_eq!(3 + 4 + 5, (3..=5).sum());

    // assert_eq!((1..=5), RangeInclusive::new(1, 5)); // Correct
    // assert_eq!((1..6), RangeInclusive::new(1, 5));  // Wrong

    //**************************************************************************************************
    // CASE 09: LAST EXAMPLE
    //**************************************************************************************************
    // Integer addition
    assert!(1u32 + 2 == 3u32);

    // Integer subtraction
    assert!(1i32 - 2 == -1i32);
    assert!(1i8 - 2 == -1); 
    
    assert!(3 * 50 == 150);

    assert!(9.6 / 3.2 == 3.0f32); // error ! make it work

    assert!(24 % 5 == 4);
    // Short-circuiting boolean logic
    assert!(true && false == false);
    assert!(true || false == true);
    assert!(!true == false);

    // Bitwise operations
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);
 
1011101
 
1111101
 

T and T = T 
T and F = F
F and T = F
F and F = F
 
    for i in Range(1, 5){
 
std::ops::
 
sum+=i;
 
    let mut sum=0;
 
std::ops::
 
.to_string()
 
 RANGE
 
:f32
 
at matches size of a word in given platform.
 
 * It is a pointer type th
 
Method B
1. 
 

Method A
 
fn define_x() -> String {
    println!("// Initialize the Variable!");
    "hello".to_string()
}

 
    //**************************************************************************************************
    // CHAPTER 01: Variable
    //**************************************************************************************************
    /*
    Note
    1. end with ;
    2. Scope
     * # The Scope of the variable is defined by the block of code where it belong to.
    3. Shadowing
     * It is the process of create new variable with same scope and same name.
    4. Function
     * Reusable Code
    */
    //------------------------------------------------------------------------
    // SUB 01: BOOL
    //------------------------------------------------------------------------
    let che_truth: bool = true;
    let che_lyring: bool = false;
    let mut che_paradox: bool = true;
    che_paradox = false;

    //------------------------------------------------------------------------
    // SUB 02: STRING
    //------------------------------------------------------------------------
    let che_string: &str = "Hello";
    let che_char = 'c';
    // How to concat string?
    // https://stackoverflow.com/questions/30154541/how-do-i-concatenate-strings
    let mut che_mutstring: String = "Phuri".to_owned();
    let che_familyname = " Sottatipreedawong";
    che_mutstring.push_str(che_familyname);
    println!("");

    // What is the different between String and &str?
    // https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str

    //------------------------------------------------------------------------
    // SUB 03: NUMBER
    //------------------------------------------------------------------------
    /*
    Note
    1. The variable number cannot be larger than the largest number that have the same type.

    Set
    1. Z = integer
     * e.g. ...,-2,-1,0,1,2,... etc.
    2. N = natural number (include 0)
     * e.g. 0,1,2,3,... etc.
    3. Q = fractional number
     * e.g. 1/2, 3/8, 44/15 etc.


    Type
    1.  i8___ = -128        < x < 127
    2.  i16__ = -(327...+1) < x < 32767
    3.  i32__ = -(214...+1) < x < 2147483647
    4.  i64__ = -(922...+1) < x < 9223372036854775807
    5.  isize = -(922...+1) < x < 9223372036854775807
    6.  i128_ = -(170...+1) < x < 170141183460469231731687303715884105727
    7.  u8___ = -1 < x < 255
    8.  u16__ = -1 < x < 65535
    9.  u32__ = -1 < x < 4294967295
    10. u64__ = -1 < x < 18446744073709551615
    11. usize = -1 < x < 18446744073709551615
    12. u128_ = -1 < x < 340282366920938463463374607431768211455
    13. f32
     * single-precision float
     * MIN: -340282350000000000000000000000000000000
     * MAX: 340282350000000000000000000000000000000
    14. f64
     * double-precision float
     * MIM: -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
     * MAX: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    Note
    1. iN = -(2^N)/2 < x < (2^N)/2-1
    2. uN = -1 < x < 2^N

    */

    let che_i8: i8 = 112;
    let che_default_i: i32 = -666;
    let che_default_u: u32 = 999;
    let che_zero: u32 = 0;

    /*
    // let che_error_i8:i8=128;
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    */

    // println!("i8___:{}",i8::MAX);       // i8___: 127
    // println!("i16__:{}",i16::MAX);      // i16__: 32767
    // println!("i32__:{}",i32::MAX);      // i32__: 2147483647
    // println!("i64__:{}",i64::MAX);      // i64__: 9223372036854775807
    // println!("isize:{}",isize::MAX);    // isize: 9223372036854775807
    // println!("i128_:{}",i128::MAX);     // i128_: 170141183460469231731687303715884105727
    // println!("u8___:{}",u8::MAX);       // u8___: 255
    // println!("u16__:{}",u16::MAX);      // u16__: 65535
    // println!("u32__:{}",u32::MAX);      // u32__: 4294967295
    // println!("u64__:{}",u64::MAX);      // u64__: 18446744073709551615
    // println!("usize:{}",usize::MAX);    // usize: 18446744073709551615
    // println!("u128_:{}",u128::MIN);     // u128_: 340282366920938463463374607431768211455
    // println!("f32__:{}",f32::MIN);      // f32__: 340282350000000000000000000000000000000
    // println!("f64__:{}",f64::MIN);      // f64__: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

    //**************************************************************************************************
    // SUB 04: FUNCTION
    //**************************************************************************************************
    // https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
    // let x:String=define_x();
    // println!("let x = {}",x);

    //**************************************************************************************************
    // SUB 05: SHADOW
    //**************************************************************************************************
    // let light:&str="Light";
    // println!("Original value: {}", light);
    // let light:&str="Shadow";
    // println!("Original value: {}", light);
    // let light:u8=100;
    //**************************************************************************************************
    // SUB 06: DESTRUCTURING
    //**************************************************************************************************
    // let (mut x, y) = (1, 2);
    // println!("{} == 1",x);
    // x += 2;
    // println!("{} == 3",x);

    //**************************************************************************************************
    // SUB 07: DECLARES MULTIPLE VARIABLES AT ONE LINE
    //**************************************************************************************************
    let (x, y, z, w)=(2,4,8,16);
 
https://youtu.be/ygL_xcavzQ4?si=fjGFFfamtpNByIw6
 

*************************************************
 
//*************************************************
 

//**************************************************************************************************
// SUB 06: SHADOW
 

// Rust
 
// Typescript
function define_x():string{
    return "hello"
}
 
/*
Question
1. What is the different between String and &str? 
2. What is the different between i32, u32 and f32?
3.
*/
 
let x = 
 
.to_string()
 
define_x
 
/*
i8___:-128
i16__:-32768
i32__:-2147483648
i64__:-9223372036854775808
isize:-9223372036854775808
i128_:-170141183460469231731687303715884105728
u8___:0
u16__:0
u32__:0
u64__:0
usize:0
u128_:0
*/
 
-1
 
 * MAX:
 
 = single
 
// Valid Code
 
-
 
.to_string()
 
che_mutstring+
 
.to_string()
 
Rule
1. let variable:type=value;
2. end with ;
3. Scope 
 * # The Scope of the variable is defined by the block of code where it belong to.
4. Shadowing
 * It is the process of create new variable with same scope and same name.
5. Function
 * Reusable Code
6. only variable that have `mut` is mutable
 
6. only variable that have `mut` is mutable
 
1. let variable:type=value;
 
//**************************************************************************************************
// Ch01
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
//**************************************************************************************************
    // mut = mutable
    /*
    let mut UserAnswer:String=String::new();
    println!("What is the value of e");
    let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
    println!("That is correct.");
    println!("The value of e is {}.", UserAnswer);
    // println!("no of bytes read , {}", b1);
    */
//**************************************************************************************************
//**************************************************************************************************
// Ch01: Data Type
// * https://www.codingame.com/playgrounds/365/getting-started-with-rust/primitive-data-types
//**************************************************************************************************
    let che_bool:bool=true;
    let che_char='c'; 
    // let che_Error_i8:i8=128; 
    // literal out of range for `i8`
    // the literal `128` does not fit into the type `i8` whose range is `-128..=127`
    // consider using the type `u8` instead
    println!("i8___:{}",i8::MAX);       // i8___ = 127
    println!("i16__:{}",i16::MAX);      // i16__ = 32767
    println!("i32__:{}",i32::MAX);      // i32__ = 2147483647
    println!("i64__:{}",i64::MAX);      // i64__ = 9223372036854775807
    println!("isize:{}",isize::MAX);    // isize = 9223372036854775807
    println!("i128_:{}",i128::MAX);     // i128_ = 170141183460469231731687303715884105727
    println!("u8___:{}",u8::MAX);       // u8___ = 255
    println!("u16__:{}",u16::MAX);      // u16__ = 65535
    println!("u32__:{}",u32::MAX);      // u32__ = 4294967295
    println!("u64__:{}",u64::MAX);      // u64__ = 18446744073709551615
    println!("usize:{}",usize::MAX);    // usize = 18446744073709551615
    println!("u128_:{}",u128::MAX);     // u128_ = 340282366920938463463374607431768211455
    println!("f32__:{}",f32::MAX);      // f32__ = 340282350000000000000000000000000000000
    println!("f64__:{}",f64::MAX);      // f64__ = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
 
    */   
 
    /* 
 
    let che_i8:i8=12021;
 
    println!("u128::{}",u128::MAX);
    println!("u128::{}",u128::MAX);
 
// * https://www.tutorialspoint.com/rust/rust_input_output.htm 
 
// https://youtu.be/07pDD0uLjYc?si=Ar7cNF_yXScZjPTt
 
    let mut RealAnswer:Number=2.7
 

    /*
    
    println!("no of bytes read , {}", b1);
    */
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
let mut UserAnswer:String=String::new();
 
let mut UserAnswer:String=String::new();
 
The value of e{}", UserAnswer)
 
let b1 = std::io::stdin().read_line(&mut UserAnswer).unwrap();
 
println!("Hello, {}",UserAnswer.trim_end());
 
println!("What is the value of e");
 
    let mut OnlyNumber:&str="This is not a number";
    let mut LessThan:&str="e is Less than";
    let mut GreaterThan:&str="e is Greater than";
 
world!
 
#![allow(unused)]
 
